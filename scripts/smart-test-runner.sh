#!/bin/bash
# smart-test-runner.sh v1.1.0
# Generated by @esteban-url/trailhead-cli
# Intelligent test execution for git pre-commit hooks

set -euo pipefail

SCRIPT_VERSION="1.1.0"
CLI_VERSION="0.1.0"

# Cache variables
STAGED_FILES_CACHE=""
CACHE_TIMESTAMP=0

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CONFIG_FILE=".smart-test-config.json"
DRY_RUN=false
VERBOSE=false
FORCE_TESTS=false
SKIP_TESTS=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --force)
      FORCE_TESTS=true
      shift
      ;;
    --skip)
      SKIP_TESTS=true
      shift
      ;;
    --help)
      echo "Usage: $0 [--dry-run] [--verbose] [--force] [--skip] [--help]"
      echo ""
      echo "Options:"
      echo "  --dry-run    Show what would be executed without running tests"
      echo "  --verbose    Show detailed information about file detection"
      echo "  --force      Force full test suite execution"
      echo "  --skip       Skip all test execution"
      echo "  --help       Show this help message"
      echo ""
      echo "Environment variables:"
      echo "  FORCE_TESTS=1    Force full test suite execution"
      echo "  SKIP_TESTS=1     Skip all test execution"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Check environment variables
if [[ "${FORCE_TESTS:-}" == "1" ]]; then
  FORCE_TESTS=true
fi

if [[ "${SKIP_TESTS:-}" == "1" ]]; then
  SKIP_TESTS=true
fi

# Logging functions
log_info() {
  echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

log_success() {
  echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
  echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

log_error() {
  echo -e "${RED}‚ùå $1${NC}"
}

log_verbose() {
  if [[ "$VERBOSE" == "true" ]]; then
    echo -e "${BLUE}üîç $1${NC}" >&2
  fi
}

# Load configuration with graceful degradation
has_config() {
  [[ -f "$CONFIG_FILE" ]] && command -v jq &> /dev/null
}

has_jq() {
  command -v jq &> /dev/null
}

# Parse JSON without jq (fallback)
parse_json_fallback() {
  local key="$1"
  local default="$2"
  local file="$3"
  
  if [[ ! -f "$file" ]]; then
    echo "$default"
    return
  fi
  
  # Simple pattern matching for basic JSON values
  case "$key" in
    ".timeout")
      grep -o '"timeout"[[:space:]]*:[[:space:]]*[0-9]*' "$file" | grep -o '[0-9]*' || echo "$default"
      ;;
    ".parallelTesting")
      if grep -q '"parallelTesting"[[:space:]]*:[[:space:]]*true' "$file"; then
        echo "true"
      elif grep -q '"parallelTesting"[[:space:]]*:[[:space:]]*false' "$file"; then
        echo "false"
      else
        echo "$default"
      fi
      ;;
    ".testCommand")
      grep -o '"testCommand"[[:space:]]*:[[:space:]]*"[^"]*"' "$file" | sed 's/.*"\([^"]*\)".*/\1/' || echo "$default"
      ;;
    *)
      echo "$default"
      ;;
  esac
}

# Get staged files with caching
get_staged_files() {
  local current_time
  current_time=$(date +%s)
  
  # Cache for 5 seconds to avoid repeated git calls
  if [[ -n "$STAGED_FILES_CACHE" && $((current_time - CACHE_TIMESTAMP)) -lt 5 ]]; then
    echo "$STAGED_FILES_CACHE"
    return
  fi
  
  local files
  files=$(git diff --cached --name-only 2>/dev/null || echo "")
  
  STAGED_FILES_CACHE="$files"
  CACHE_TIMESTAMP="$current_time"
  
  echo "$files"
}

# Get configuration value with fallback and error handling
get_config_value() {
  local key="$1"
  local default="$2"
  
  if [[ ! -f "$CONFIG_FILE" ]]; then
    log_verbose "Config file $CONFIG_FILE not found, using default: $default"
    echo "$default"
    return
  fi
  
  if has_jq; then
    local result
    if result=$(jq -r "$key // \"$default\"" "$CONFIG_FILE" 2>/dev/null); then
      echo "$result"
    else
      log_verbose "Failed to parse $key from config with jq, trying fallback"
      parse_json_fallback "$key" "$default" "$CONFIG_FILE"
    fi
  else
    log_verbose "jq not available, using JSON fallback parser"
    parse_json_fallback "$key" "$default" "$CONFIG_FILE"
  fi
}

# Check if files match patterns
files_match_pattern() {
  local files="$1"
  local pattern="$2"
  
  if [[ -z "$files" ]] || [[ -z "$pattern" ]]; then
    return 1
  fi
  
  echo "$files" | grep -qE "$pattern"
}

# Detect file risk level
detect_risk_level() {
  local staged_files="$1"
  
  log_verbose "Analyzing $(echo "$staged_files" | wc -l) staged files"
  
  # High-risk patterns
  local high_risk_patterns
  if has_config; then
    high_risk_patterns=$(jq -r '.highRiskPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$high_risk_patterns" ]]; then
    high_risk_patterns='\.(ts|tsx|js|jsx)$|tsconfig|package\.json$|turbo\.json$|vitest\.config|vite\.config'
  fi
  
  # Skip patterns  
  local skip_patterns
  if has_config; then
    skip_patterns=$(jq -r '.skipPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$skip_patterns" ]]; then
    skip_patterns='\.md$|README|CHANGELOG|LICENSE|\.github/|\.vscode/|\.gitignore$|\.prettierrc|\.prettierignore|docs/|\.smart-test-config\.json$|\.mcp\.json$|scripts/.*\.sh$'
  fi
  
  log_verbose "High-risk patterns: $high_risk_patterns"
  log_verbose "Skip patterns: $skip_patterns"
  
  # Check for high-risk files
  if files_match_pattern "$staged_files" "$high_risk_patterns"; then
    log_verbose "Found high-risk files"
    echo "high"
    return 0
  fi
  
  # Check for package-specific changes
  if files_match_pattern "$staged_files" "^packages/"; then
    log_verbose "Found package-specific changes"
    echo "medium"
    return 0
  fi
  
  # Check if all files match skip patterns
  local non_skip_files
  non_skip_files=$(echo "$staged_files" | grep -vE "$skip_patterns" || echo "")
  
  if [[ -z "$non_skip_files" ]]; then
    log_verbose "All files match skip patterns"
    echo "skip"
    return 0
  fi
  
  # Default to medium risk
  log_verbose "Defaulting to medium risk"
  echo "medium"
}

# Get affected packages
get_affected_packages() {
  local staged_files="$1"
  
  # Extract unique packages from staged files
  echo "$staged_files" | grep -E "^packages/([^/]+)/" | cut -d'/' -f2 | sort -u
}

# Get package filter name
get_package_filter() {
  local package="$1"
  
  # Try to get from config first
  if has_config; then
    local filter
    filter=$(jq -r ".packageMappings.\"$package\" // \"\"" "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$filter" ]]; then
      echo "$filter"
      return 0
    fi
  fi
  
  # Default mappings
  case "$package" in
    "cli")
      echo "@esteban-url/trailhead-cli"
      ;;
    "web-ui")
      echo "@esteban-url/trailhead-web-ui"
      ;;
    "create-trailhead-cli")
      echo "@esteban-url/create-trailhead-cli"
      ;;
    *)
      echo "$package"
      ;;
  esac
}

# Execute tests with retry logic and progress indicators
execute_tests() {
  local test_command="$1"
  local description="$2"
  local max_retries=${3:-1}
  
  log_info "$description"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "DRY RUN: Would execute: $test_command"
    return 0
  fi
  
  log_verbose "Executing: $test_command"
  
  # Get timeout and retry settings from config
  local timeout
  timeout=$(get_config_value '.timeout' '120')
  local retry_enabled
  retry_enabled=$(get_config_value '.retryFlaky' 'true')
  
  if [[ "$retry_enabled" == "true" && "$max_retries" -gt 1 ]]; then
    max_retries=$(get_config_value '.maxRetries' '2')
  fi
  
  local attempt=1
  while [[ $attempt -le $max_retries ]]; do
    if [[ $max_retries -gt 1 ]]; then
      log_info "üîÑ Attempt $attempt of $max_retries"
    fi
    
    # Show progress for long-running commands
    local progress_pid=""
    if [[ "$VERBOSE" != "true" && "$timeout" -gt 30 ]]; then
      show_progress &
      progress_pid=$!
    fi
    
    # Execute with timeout (handle macOS vs Linux timeout command)
    local exit_code=0
    local timeout_cmd="timeout"
    
    # Check if timeout command is available, fallback to gtimeout on macOS
    if ! command -v timeout >/dev/null 2>&1; then
        if command -v gtimeout >/dev/null 2>&1; then
            timeout_cmd="gtimeout"
        else
            log_warning "Neither 'timeout' nor 'gtimeout' found. Install coreutils for timeout support."
            log_info "Running tests without timeout..."
            if bash -c "$test_command"; then
                if [[ -n "$progress_pid" ]]; then
                    kill $progress_pid 2>/dev/null || true
                    echo # New line after progress
                fi
                log_success "Tests completed successfully"
                return 0
            else
                exit_code=$?
                if [[ -n "$progress_pid" ]]; then
                    kill $progress_pid 2>/dev/null || true
                    echo # New line after progress
                fi
                log_error "Tests failed (exit code: $exit_code)"
                return $exit_code
            fi
        fi
    fi
    
    # Use timeout command if available
    if $timeout_cmd "${timeout}s" bash -c "$test_command"; then
        if [[ -n "$progress_pid" ]]; then
            kill $progress_pid 2>/dev/null || true
            echo # New line after progress
        fi
        log_success "Tests completed successfully"
        return 0
    else
        exit_code=$?
        if [[ -n "$progress_pid" ]]; then
            kill $progress_pid 2>/dev/null || true
            echo # New line after progress
        fi
        
        if [[ $exit_code -eq 124 ]]; then
            log_error "Tests timed out after ${timeout}s"
            return $exit_code # Don't retry timeouts
        elif [[ $attempt -lt $max_retries ]]; then
            log_warning "Tests failed (attempt $attempt/$max_retries), retrying..."
            sleep 2 # Brief pause before retry
        else
            log_error "Tests failed with exit code $exit_code after $max_retries attempts"
            return $exit_code
        fi
    fi
    
    ((attempt++))
  done
}

# Detect package manager
detect_package_manager() {
  if [[ -f "pnpm-lock.yaml" ]]; then
    echo "pnpm"
  elif [[ -f "yarn.lock" ]]; then
    echo "yarn"
  elif [[ -f "package-lock.json" ]]; then
    echo "npm"
  else
    echo "npm"  # default fallback
  fi
}

# Show progress indicator for long-running tests
show_progress() {
  local chars="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
  local delay=0.1
  local i=0
  
  while true; do
    printf "\r${BLUE}%s Tests running...${NC}" "${chars:$i:1}"
    sleep $delay
    i=$(( (i + 1) % ${#chars} ))
  done
}

# Main execution logic
main() {
  log_info "Smart Test Runner v$SCRIPT_VERSION"
  
  # Check for skip flag
  if [[ "$SKIP_TESTS" == "true" ]]; then
    log_warning "Skipping all tests (SKIP_TESTS=1 or --skip)"
    return 0
  fi
  
  # Get staged files
  local staged_files
  staged_files=$(get_staged_files)
  
  if [[ -z "$staged_files" ]]; then
    log_warning "No staged files found"
    return 0
  fi
  
  log_verbose "Found $(echo "$staged_files" | wc -l) staged files"
  
  # Get test command from config
  local test_command
  test_command=$(get_config_value '.testCommand' 'pnpm test')
  
  # Force full test suite if requested
  if [[ "$FORCE_TESTS" == "true" ]]; then
    execute_tests "$test_command" "üî¥ Forced full test suite execution"
    return $?
  fi
  
  # Detect risk level
  local risk_level
  risk_level=$(detect_risk_level "$staged_files")
  
  log_verbose "Detected risk level: $risk_level"
  
  case "$risk_level" in
    "high")
      execute_tests "$test_command" "üî¥ Code changes detected - running full test suite"
      return $?
      ;;
    "medium")
      # Get affected packages
      local affected_packages
      affected_packages=$(get_affected_packages "$staged_files")
      
      if [[ -z "$affected_packages" ]]; then
        log_warning "Package changes detected but no packages identified, running full test suite"
        execute_tests "$test_command" "üü° Running full test suite (package detection failed)"
        return $?
      fi
      
      log_info "üü° Package changes detected - running affected tests"
      
      # Check if parallel testing is supported and enabled
      local enable_parallel_testing
      enable_parallel_testing=$(get_config_value '.parallelTesting' 'true')
      
      # Run tests for each affected package
      local overall_exit_code=0
      local pm
      pm=$(detect_package_manager)
      
      if [[ "$enable_parallel_testing" == "true" && "$pm" == "pnpm" ]]; then
        # Parallel execution for pnpm (supports workspace concurrency)
        log_info "üîÑ Running tests in parallel for affected packages"
        
        local package_filters=()
        while IFS= read -r package; do
          if [[ -n "$package" ]]; then
            local package_filter
            package_filter=$(get_package_filter "$package")
            package_filters+=("$package_filter")
          fi
        done <<< "$affected_packages"
        
        if [[ ${#package_filters[@]} -gt 0 ]]; then
          local parallel_filter
          parallel_filter=$(printf "%s," "${package_filters[@]}")
          parallel_filter="{${parallel_filter%,}}" # Remove trailing comma and wrap in braces
          
          local parallel_test_command="$test_command --filter=$parallel_filter"
          local max_retries
          max_retries=$(get_config_value '.maxRetries' '2')
          
          if ! execute_tests "$parallel_test_command" "Testing packages in parallel: ${package_filters[*]}" "$max_retries"; then
            overall_exit_code=$?
          fi
        fi
      else
        # Sequential execution (fallback or explicitly disabled)
        if [[ "$enable_parallel_testing" != "true" ]]; then
          log_info "üîÑ Running tests sequentially (parallel testing disabled)"
        else
          log_info "üîÑ Running tests sequentially (parallel testing not supported for $pm)"
        fi
        
        local max_retries
        max_retries=$(get_config_value '.maxRetries' '2')
        
        while IFS= read -r package; do
          if [[ -n "$package" ]]; then
            local package_filter
            package_filter=$(get_package_filter "$package")
            
            local package_test_command
            if [[ "$pm" == "pnpm" ]]; then
              package_test_command="$test_command --filter=$package_filter"
            else
              # For non-pnpm, try to cd into package directory
              if [[ -d "packages/$package" ]]; then
                package_test_command="cd packages/$package && $test_command"
              else
                package_test_command="$test_command"
              fi
            fi
            
            if ! execute_tests "$package_test_command" "Testing package: $package ($package_filter)" "$max_retries"; then
              overall_exit_code=$?
            fi
          fi
        done <<< "$affected_packages"
      fi
      
      return $overall_exit_code
      ;;
    "skip")
      log_success "üü¢ Documentation/config changes only - skipping tests"
      return 0
      ;;
    *)
      log_warning "Unknown risk level: '$risk_level', running full test suite"
      execute_tests "$test_command" "üü° Running full test suite (unknown risk level)"
      return $?
      ;;
  esac
}

# Run main function
main "$@"