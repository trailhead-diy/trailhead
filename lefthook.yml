# Lefthook configuration for high-performance git hooks
# https://github.com/evilmartians/lefthook

# Skip hooks with SKIP_HOOKS=1 or LEFTHOOK=0
skip_output:
  - meta

# Show execution time for performance monitoring
output:
  - summary
  - success
  - failure
  - execution
  - execution_out
  - execution_info

colors: true

pre-commit:
  parallel: true
  commands:
    # 1. Format code (fastest, auto-fix)
    prettier:
      priority: 1
      glob: "**/*.{ts,tsx,js,jsx,json,md}"
      run: pnpm prettier --write {staged_files} --cache --cache-location .turbo/.prettiercache
      stage_fixed: true

    # 2. Lint TypeScript/JavaScript with oxlint (critical errors)
    oxlint:
      priority: 2
      glob: "packages/**/*.{ts,tsx,js,jsx}"
      run: pnpm oxlint {staged_files} --fix
      stage_fixed: true

    # 3. Type check (logic errors)
    typecheck:
      priority: 3
      glob: "**/*.{ts,tsx}"
      run: pnpm types --filter="./packages/*" -- --incremental

    # 4. Validate documentation structure (if docs changed)
    docs-validate:
      priority: 4
      glob: "{docs,packages/**/docs}/**/*.md"
      run: |
        staged_docs=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(md)$' | grep -E '(docs/|packages/.*/docs/)' || true)
        if [ -n "$staged_docs" ]; then
          for file in $staged_docs; do
            pnpm docs:validate "$file"
          done
        fi

    # 5. Security and size checks (lightweight)
    security-checks:
      priority: 5
      run: |
        # Check for secrets (skip lock files)
        staged_files=$(git diff --cached --name-only | grep -vE '(pnpm-lock\.yaml|package-lock\.json|yarn\.lock)$' || true)
        if [ -n "$staged_files" ]; then
          if echo "$staged_files" | xargs grep -l -E -i "(api[_-]?key|secret|token|password)" 2>/dev/null; then
            echo "‚ö†Ô∏è Potential secrets detected"
          fi
          
          # Check file sizes (only for large files)
          large_files=$(echo "$staged_files" | xargs ls -la 2>/dev/null | awk '$5 > 1048576 {print $9, "(" $5 " bytes)"}' || true)
          if [ -n "$large_files" ]; then
            echo "‚ö†Ô∏è Large files detected:"
            echo "$large_files"
          fi
        fi

    # 6. Smart test execution (comprehensive validation)
    smart-tests:
      priority: 6
      run: ./scripts/smart-test-runner.sh

    # 7. Build validation (conditional)
    build-affected:
      priority: 7
      glob: "**/*.{ts,tsx,js,jsx,json}"
      run: |
        echo "üî® Building affected packages..."
        # Use Turborepo's affected detection with caching
        pnpm turbo build --filter='...[HEAD^1]' --cache-dir=.turbo || {
          echo "‚ùå Build failed - this would fail in CI"
          exit 1
        }
        echo "‚úÖ Build validation passed"

    # 8. Workspace dependency validation
    workspace-check:
      priority: 8
      run: |
        # Only run when package.json files change
        if git diff --cached --name-only | grep -q 'package\.json$'; then
          echo "üì¶ Validating workspace dependencies..."
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            try {
              // Get all package.json files
              const packages = [];
              const packageDirs = ['packages/cli', 'packages/web-ui', 'packages/create-trailhead-cli'];
              
              for (const dir of packageDirs) {
                const pkgPath = path.join(dir, 'package.json');
                if (fs.existsSync(pkgPath)) {
                  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                  packages.push({ dir, pkg });
                }
              }
              
              let errors = [];
              
              // Check workspace: protocol usage
              for (const { dir, pkg } of packages) {
                const deps = { ...pkg.dependencies, ...pkg.devDependencies };
                for (const [name, version] of Object.entries(deps)) {
                  if (name.startsWith('@repo/') && !version.startsWith('workspace:')) {
                    errors.push(\`\${dir}: Internal dependency '\${name}' should use 'workspace:*' protocol\`);
                  }
                }
              }
              
              if (errors.length > 0) {
                console.error('‚ùå Workspace dependency validation failed:');
                errors.forEach(err => console.error('  ' + err));
                process.exit(1);
              } else {
                console.log('‚úÖ Workspace dependencies validated');
              }
            } catch (err) {
              console.log('‚ö†Ô∏è Workspace validation skipped:', err.message);
            }
          " || exit 1
        else
          echo "‚ÑπÔ∏è No package.json changes, skipping workspace validation"
        fi
        
    # 9. Environment parity check
    env-check:
      priority: 9
      run: |
        echo "üåç Checking environment parity..."
        node -e "
          const fs = require('fs');
          // Use built-in version comparison instead of semver
          function satisfies(version, range) {
            // Simple version check - remove 'v' prefix and handle basic ranges
            const cleanVersion = version.replace(/^v/, '');
            
            // Handle different range operators
            if (range.startsWith('>=')) {
              const minVersion = range.substring(2);
              const [vMajor, vMinor = 0, vPatch = 0] = cleanVersion.split('.').map(Number);
              const [rMajor, rMinor = 0, rPatch = 0] = minVersion.split('.').map(Number);
              
              if (vMajor > rMajor) return true;
              if (vMajor < rMajor) return false;
              if (vMinor > rMinor) return true;
              if (vMinor < rMinor) return false;
              return vPatch >= rPatch;
            }
            
            // Default to basic equality check
            return cleanVersion.startsWith(range.replace(/[>=~^]/, ''));
          }
          
          try {
            // Check Node version against engines
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const nodeVersion = process.version;
            const engines = pkg.engines?.node;
            
            if (engines && !satisfies(nodeVersion, engines)) {
              console.error(\`‚ùå Node version mismatch: current \${nodeVersion}, required \${engines}\`);
              process.exit(1);
            }
            
            // Check pnpm version if specified
            const pnpmVersion = pkg.engines?.pnpm;
            if (pnpmVersion) {
              try {
                const { execSync } = require('child_process');
                const currentPnpm = execSync('pnpm --version', { encoding: 'utf8' }).trim();
                if (!satisfies(currentPnpm, pnpmVersion)) {
                  console.error(\`‚ùå PNPM version mismatch: current \${currentPnpm}, required \${pnpmVersion}\`);
                  process.exit(1);
                }
              } catch (err) {
                console.log('‚ö†Ô∏è Could not check PNPM version');
              }
            }
            
            console.log('‚úÖ Environment parity check passed');
          } catch (err) {
            console.log('‚ö†Ô∏è Environment check skipped:', err.message);
          }
        " || exit 1
        
    # 10. Package.json validation
    package-validation:
      priority: 10
      run: |
        # Only run when package.json files change
        if git diff --cached --name-only | grep -q 'package\.json$'; then
          echo "üìã Validating package.json files..."
          node -e '
            const fs = require("fs");
            const path = require("path");
            
            try {
              // Get all package.json files
              const packages = [];
              const packageDirs = ["packages/cli", "packages/web-ui", "packages/create-trailhead-cli"];
              
              for (const dir of packageDirs) {
                const pkgPath = path.join(dir, "package.json");
                if (fs.existsSync(pkgPath)) {
                  const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
                  packages.push({ dir, pkg, path: pkgPath });
                }
              }
              
              let errors = [];
              let warnings = [];
              
              // 1. Required scripts validation
              const requiredScripts = ["build", "test", "lint", "types"];
              for (const { dir, pkg } of packages) {
                for (const script of requiredScripts) {
                  if (!pkg.scripts || !pkg.scripts[script]) {
                    errors.push(`${dir}: Missing required script "${script}"`);
                  }
                }
              }
              
              // 2. License consistency
              for (const { dir, pkg } of packages) {
                if (!pkg.license) {
                  errors.push(`${dir}: Missing license field`);
                } else if (pkg.license !== "MIT") {
                  warnings.push(`${dir}: License "${pkg.license}" may not match expected "MIT"`);
                }
              }
              
              // 3. Repository field consistency
              for (const { dir, pkg } of packages) {
                if (!pkg.repository) {
                  errors.push(`${dir}: Missing repository field`);
                } else if (typeof pkg.repository === "object") {
                  if (!pkg.repository.directory) {
                    errors.push(`${dir}: Repository missing directory field for monorepo`);
                  } else if (pkg.repository.directory !== dir) {
                    errors.push(`${dir}: Repository directory "${pkg.repository.directory}" does not match actual path "${dir}"`);
                  }
                }
              }
              
              // Report results
              if (warnings.length > 0) {
                console.log("‚ö†Ô∏è Package.json warnings:");
                warnings.forEach(warn => console.log("  " + warn));
              }
              
              if (errors.length > 0) {
                console.error("‚ùå Package.json validation failed:");
                errors.forEach(err => console.error("  " + err));
                process.exit(1);
              } else {
                console.log("‚úÖ Package.json validation passed");
              }
            } catch (err) {
              console.log("‚ö†Ô∏è Package.json validation skipped:", err.message);
            }
          ' || exit 1
        else
          echo "‚ÑπÔ∏è No package.json changes, skipping validation"
        fi

prepare-commit-msg:
  commands:
    changeset-reminder:
      run: |
        if git diff --cached --name-only | grep -q "^packages/"; then
          echo "üìù Reminder: If this change should be released, don't forget to add a changeset!"
          echo "   Run: pnpm changeset:add"
        fi
      skip:
        - merge
        - rebase

commit-msg:
  commands:
    commitlint:
      run: 'first_line=$(head -n1 {1}); if ! echo "$first_line" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+$"; then echo "‚ùå Commit message must follow conventional format:"; echo "   type(scope?): description"; echo "   Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"; echo "   Example: feat(web-ui): add dark mode support"; exit 1; fi'

pre-push:
  parallel: true
  commands:
    # Validate lockfile is up to date (simplified)
    lockfile-check:
      priority: 1
      run: |
        echo "üîí Checking if pnpm-lock.yaml is up to date..."
        pnpm install --lockfile-only --frozen-lockfile || {
          echo "‚ùå pnpm-lock.yaml is out of date! Run 'pnpm install' and commit the updated lockfile"
          exit 1
        }
        echo "‚úÖ Lockfile is up to date"

    # Check branch sync status (warning only)
    branch-sync-check:
      priority: 2
      run: |
        echo "üåø Checking branch sync status..."
        cd packages/cli && pnpm build > /dev/null 2>&1
        node --input-type=module -e "
          import { checkBranchSync, formatSyncStatus } from './dist/git/index.js';
          (async () => {
            const result = await checkBranchSync('origin/main', { fetch: true });
            if (!result.success) {
              console.log('‚ÑπÔ∏è Could not check branch sync:', result.error.message);
              process.exit(0);
            }
            const status = result.value;
            if (!status.isUpToDate) {
              console.log('‚ö†Ô∏è ' + formatSyncStatus(status));
              if (status.behind > 10) {
                console.log('‚ùå Branch is significantly behind. Please sync before pushing.');
                process.exit(1);
              }
            } else {
              console.log('‚úÖ Branch is up to date with origin/main');
            }
          })().catch(err => {
            console.log('‚ÑπÔ∏è Branch sync check failed:', err.message);
            process.exit(0);
          });
        "

# Personal overrides (not committed)
# Create .lefthook-local.yml to customize
