import { createCommand } from '@esteban-url/trailhead-cli/command'
import { Ok, Err, createError } from '@esteban-url/trailhead-cli/core'
import { createValidationPipeline } from '@esteban-url/trailhead-cli/core'
import { glob } from 'glob'
import { readFile } from 'fs/promises'
import { z } from 'zod'
import type { Result } from '@esteban-url/trailhead-cli/core'
import type { CommandOptions } from '@esteban-url/trailhead-cli/command'

/**
 * Validate Command
 * 
 * Advanced example demonstrating:
 * - Validation pipeline architecture
 * - File system validation
 * - Schema validation
 * - Custom validation rules
 * - Batch validation with reporting
 */
interface ValidateOptions extends CommandOptions {
  config?: boolean;
  source?: boolean;
  tests?: boolean;
  fix?: boolean;
  pattern?: string;
}

export const validateCommand = createCommand<ValidateOptions>({
  name: 'validate',
  description: 'Validate project files and configuration',
  options: [
    {
      flags: '-c, --config',
      description: 'Validate configuration files only',
      type: 'boolean'
    },
    {
      flags: '-s, --source',
      description: 'Validate source code files',
      type: 'boolean'
    },
    {
      flags: '-t, --tests',
      description: 'Validate test files',
      type: 'boolean'
    },
    {
      flags: '-f, --fix',
      description: 'Auto-fix validation issues where possible',
      type: 'boolean'
    },
    {
      flags: '-p, --pattern <pattern>',
      description: 'File pattern to validate (glob)',
      type: 'string'
    }
  ],
  action: async (options, context) => {
    const { logger, verbose } = context
    
    try {
      logger.info('Running project validation...')
      
      const validationResults: ValidationResult[] = []
      
      // Determine what to validate
      const validateAll = !options.config && !options.source && !options.tests
      const shouldValidateConfig = validateAll || options.config
      const shouldValidateSource = validateAll || options.source
      const shouldValidateTests = validateAll || options.tests
      
      // Validate configuration files
      if (shouldValidateConfig) {
        const configResults = await validateConfigurationFiles(verbose)
        validationResults.push(...configResults)
      }
      
      // Validate source files
      if (shouldValidateSource) {
        const pattern = options.pattern || 'src/**/*.{ts,js}'
        const sourceResults = await validateSourceFiles(pattern, verbose)
        validationResults.push(...sourceResults)
      }
      
      // Validate test files
      if (shouldValidateTests) {
        const testPattern = options.pattern || 'src/**/__tests__/**/*.{test,spec}.{ts,js}'
        const testResults = await validateTestFiles(testPattern, verbose)
        validationResults.push(...testResults)
      }
      
      // Process results
      const errors = validationResults.filter(r => r.level === 'error')
      const warnings = validationResults.filter(r => r.level === 'warning')
      const infos = validationResults.filter(r => r.level === 'info')
      
      // Apply fixes if requested
      if (options.fix && errors.length > 0) {
        logger.info('Attempting to fix validation issues...')
        const fixResults = await applyFixes(errors)
        logger.info(`Fixed ${fixResults.fixed} issues, ${fixResults.failed} failed`)
      }
      
      // Report results
      if (verbose || warnings.length > 0) {
        warnings.forEach(result => {
          logger.error(`${result.file}: ${result.message}`)
        })
      }
      
      if (verbose || infos.length > 0) {
        infos.forEach(result => {
          logger.info(`${result.file}: ${result.message}`)
        })
      }
      
      errors.forEach(result => {
        logger.error(`${result.file}: ${result.message}`)
      })
      
      // Summary
      logger.info('')
      logger.info('Validation Summary:')
      logger.info(`  ✓ ${validationResults.length - errors.length - warnings.length} passed`)
      if (warnings.length > 0) {
        logger.error(`  ⚠ ${warnings.length} warnings`)
      }
      if (errors.length > 0) {
        logger.error(`  ✗ ${errors.length} errors`)
      }
      
      if (errors.length > 0) {
        return err(createCoreError('VALIDATION_FAILED', `Validation failed with ${errors.length} errors`, {
          details: `Found ${errors.length} validation errors that need to be fixed`
        }))
      }
      
      .success('Validation completed successfully!')
      return ok(undefined)
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Validation failed: ${errorMessage}`)
      return err(createCoreError('VALIDATION_ERROR', `Validation failed: ${errorMessage}`, {
        cause: error,
        details: 'An unexpected error occurred during validation'
      }))
    }
  }
})

interface ValidationResult {
  file: string
  message: string
  level: 'error' | 'warning' | 'info'
  fixable?: boolean
}

/**
 * Validate configuration files
 */
async function validateConfigurationFiles(verbose: boolean): Promise<ValidationResult[]> {
  const results: ValidationResult[] = []
  
  try {
    const configFiles = await glob('**/*.config.{js,ts,json}', { ignore: 'node_modules/**' })
    
    for (const file of configFiles) {
      if (verbose) {
        console.log(`Validating config: ${file}`)
      }
      
      // Basic file validation
      try {
        const content = await readFile(file, 'utf-8')
        
        if (content.length === 0) {
          results.push({
            file,
            message: 'Configuration file is empty',
            level: 'warning'
          })
        } else {
          results.push({
            file,
            message: 'Configuration file is valid',
            level: 'info'
          })
        }
      } catch (error) {
        results.push({
          file,
          message: `Failed to read configuration file: ${error}`,
          level: 'error'
        })
      }
    }
  } catch (error) {
    results.push({
      file: 'config-discovery',
      message: `Failed to discover config files: ${error}`,
      level: 'error'
    })
  }
  
  return results
}

/**
 * Validate source files
 */
async function validateSourceFiles(pattern: string, verbose: boolean): Promise<ValidationResult[]> {
  const results: ValidationResult[] = []
  
  try {
    const sourceFiles = await glob(pattern, { ignore: 'node_modules/**' })
    
    for (const file of sourceFiles) {
      if (verbose) {
        console.log(`Validating source: ${file}`)
      }
      
      try {
        const content = await readFile(file, 'utf-8')
        
        // Check for common issues
        if (content.includes('console.log') && !file.includes('.test.')) {
          results.push({
            file,
            message: 'Contains console.log statements',
            level: 'warning',
            fixable: true
          })
        }
        
        if (content.includes('any') && file.endsWith('.ts')) {
          results.push({
            file,
            message: 'Contains "any" type - consider more specific types',
            level: 'warning'
          })
        }
        
        if (!content.includes('export') && !file.includes('index.')) {
          results.push({
            file,
            message: 'File does not export anything',
            level: 'warning'
          })
        }
        
        results.push({
          file,
          message: 'Source file validated',
          level: 'info'
        })
        
      } catch (error) {
        results.push({
          file,
          message: `Failed to validate source file: ${error}`,
          level: 'error'
        })
      }
    }
  } catch (error) {
    results.push({
      file: 'source-discovery',
      message: `Failed to discover source files: ${error}`,
      level: 'error'
    })
  }
  
  return results
}

/**
 * Validate test files
 */
async function validateTestFiles(pattern: string, verbose: boolean): Promise<ValidationResult[]> {
  const results: ValidationResult[] = []
  
  try {
    const testFiles = await glob(pattern, { ignore: 'node_modules/**' })
    
    for (const file of testFiles) {
      if (verbose) {
        console.log(`Validating test: ${file}`)
      }
      
      try {
        const content = await readFile(file, 'utf-8')
        
        // Check for test best practices
        if (!content.includes('describe') && !content.includes('test') && !content.includes('it')) {
          results.push({
            file,
            message: 'Test file does not contain test cases',
            level: 'warning'
          })
        }
        
        if (content.includes('test.only') || content.includes('it.only')) {
          results.push({
            file,
            message: 'Contains focused tests (.only)',
            level: 'error',
            fixable: true
          })
        }
        
        results.push({
          file,
          message: 'Test file validated',
          level: 'info'
        })
        
      } catch (error) {
        results.push({
          file,
          message: `Failed to validate test file: ${error}`,
          level: 'error'
        })
      }
    }
  } catch (error) {
    results.push({
      file: 'test-discovery',
      message: `Failed to discover test files: ${error}`,
      level: 'error'
    })
  }
  
  return results
}

/**
 * Apply automatic fixes to validation issues
 */
async function applyFixes(errors: ValidationResult[]): Promise<{ fixed: number; failed: number }> {
  let fixed = 0
  let failed = 0
  
  for (const error of errors.filter(e => e.fixable)) {
    try {
      // Implement specific fixes based on error type
      // This is a simplified example
      console.log(`Would fix: ${error.file} - ${error.message}`)
      fixed++
    } catch {
      failed++
    }
  }
  
  return { fixed, failed }
}