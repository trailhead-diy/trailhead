import { describe, it, expect, beforeEach, vi } from 'vitest'
import { createTestContext } from '@esteban-url/trailhead-cli/testing'
import { configCommand } from '../config.js'

// Mock the config module
vi.mock('@esteban-url/trailhead-cli/config', () => ({
  loadConfig: vi.fn(),
  defineConfig: vi.fn()
}))

describe('config command', () => {
  let testContext: any
  const mockLoadConfig = vi.fn()
  const mockDefineConfig = vi.fn()

  beforeEach(async () => {
    vi.clearAllMocks()
    
    testContext = createTestContext({
      verbose: false,
      args: []
    })

    // Setup default mocks
    mockDefineConfig.mockReturnValue({ schema: 'mock-schema' })
    mockLoadConfig.mockResolvedValue({
      success: true,
      value: {
        name: '{{projectName}}',
        type: 'cli',
        version: '1.0.0',
        features: {
          linting: true,
          testing: true,
          typescript: true
        },
        build: {
          outDir: 'dist',
          target: 'node18',
          sourcemap: true,
          minify: false
        }
      }
    })

    // Replace mocked modules
    const configModule = vi.mocked(await import('@esteban-url/trailhead-cli/config'))
    configModule.loadConfig.mockImplementation(mockLoadConfig)
    configModule.defineConfig.mockImplementation(mockDefineConfig)
  })

  it('should validate configuration successfully', async () => {
    const result = await configCommand.execute({ validate: true }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.success).toHaveBeenCalledWith('Configuration is valid!')
  })

  it('should handle configuration loading failure', async () => {
    mockLoadConfig.mockResolvedValue({
      success: false,
      error: new Error('Config file not found')
    })

    const result = await configCommand.execute({ validate: true }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Failed to load configuration: Config file not found')
  })

  it('should list all configuration values', async () => {
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {})
    
    const result = await configCommand.execute({ list: true }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('Current configuration:')
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('"name": "{{projectName}}"'))
    
    consoleSpy.mockRestore()
  })

  it('should get specific configuration value', async () => {
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {})
    
    const result = await configCommand.execute({ get: 'name' }, testContext)
    
    expect(result.success).toBe(true)
    expect(consoleSpy).toHaveBeenCalledWith('{{projectName}}')
    
    consoleSpy.mockRestore()
  })

  it('should get nested configuration value', async () => {
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {})
    
    const result = await configCommand.execute({ get: 'build.target' }, testContext)
    
    expect(result.success).toBe(true)
    expect(consoleSpy).toHaveBeenCalledWith('node18')
    
    consoleSpy.mockRestore()
  })

  it('should handle missing configuration key', async () => {
    const result = await configCommand.execute({ get: 'nonexistent.key' }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Configuration key not found: nonexistent.key')
  })

  it('should handle set operation', async () => {
    const result = await configCommand.execute({ set: 'build.minify=true' }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('Setting build.minify = true')
    expect(testContext.logger.warn).toHaveBeenCalledWith('Configuration updates not implemented in this example')
  })

  it('should handle invalid set format', async () => {
    const result = await configCommand.execute({ set: 'invalid-format' }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Invalid format. Use: --set key=value')
  })

  it('should handle positional arguments', async () => {
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {})
    testContext.args = ['version']
    
    const result = await configCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(consoleSpy).toHaveBeenCalledWith('1.0.0')
    
    consoleSpy.mockRestore()
  })

  it('should show configuration summary by default', async () => {
    const result = await configCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('Project: {{projectName}} (cli)')
    expect(testContext.logger.info).toHaveBeenCalledWith('Version: 1.0.0')
    expect(testContext.logger.info).toHaveBeenCalledWith('Features: linting, testing, typescript')
    expect(testContext.logger.info).toHaveBeenCalledWith('Build target: node18')
  })

  it('should handle unexpected errors', async () => {
    mockLoadConfig.mockRejectedValue(new Error('Unexpected error'))
    
    const result = await configCommand.execute({}, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Config operation failed: Unexpected error')
  })

  it('should show debug information in verbose mode', async () => {
    testContext.verbose = true
    
    const result = await configCommand.execute({ validate: true }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.debug).toHaveBeenCalledWith('Configuration:', expect.any(Object))
  })
})