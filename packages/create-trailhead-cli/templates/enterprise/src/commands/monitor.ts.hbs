import { createCommand } from '@esteban-url/trailhead-cli/command'
import { Ok, Err, createError } from '@esteban-url/trailhead-cli/core'
import { select, confirm } from '@inquirer/prompts'
import type { Result } from '@esteban-url/trailhead-cli/core'
import type { CommandOptions } from '@esteban-url/trailhead-cli/command'
import { MetricsCollector } from '../monitoring/metrics.js'
import { HealthChecker, builtInHealthChecks } from '../monitoring/health.js'
import { AlertManager, builtInAlertRules } from '../monitoring/alerts.js'

interface MonitorOptions extends CommandOptions {
  mode?: string;
  interval?: number;
  export?: string;
  duration?: number;
}

/**
 * Monitor Command
 * 
 * Enterprise monitoring and observability features:
 * - Real-time metrics collection
 * - Health checks and diagnostics
 * - Alert management
 * - Performance monitoring
 * - System resource tracking
 */
export const monitorCommand = createCommand<MonitorOptions>({
  name: 'monitor',
  description: 'Monitor system health and performance',
  options: [
    {
      flags: '-m, --mode <mode>',
      description: 'Monitoring mode (dashboard|metrics|health|alerts)',
      type: 'string'
    },
    {
      flags: '-i, --interval <seconds>',
      description: 'Collection interval in seconds',
      type: 'number',
      default: 30
    },
    {
      flags: '-e, --export <format>',
      description: 'Export format (json|csv|prometheus)',
      type: 'string'
    },
    {
      flags: '-d, --duration <minutes>',
      description: 'Monitoring duration in minutes (0 for continuous)',
      type: 'number'
    }
  ],
  action: async (options, context) => {
    const { logger, verbose } = context
    
    try {
      logger.info('Starting monitoring session...')
      
      const metricsConfig = {
        enabled: true,
        interval: (options.interval || 30) * 1000,
        exporters: ['console']
      }
      
      const metricsCollector = new MetricsCollector(metricsConfig)
      const healthChecker = new HealthChecker()
      const alertManager = new AlertManager()
      
      // Determine monitoring mode
      const mode = options.mode || await select({
        message: 'Select monitoring mode:',
        choices: [
          { name: 'Dashboard - Real-time overview', value: 'dashboard' },
          { name: 'Metrics - Collect performance metrics', value: 'metrics' },
          { name: 'Health - Run health checks', value: 'health' },
          { name: 'Alerts - Manage alert rules', value: 'alerts' }
        ]
      })
      
      const interval = options.interval || 30
      const duration = options.duration || 0
      
      if (verbose) {
        logger.debug(`Monitoring mode: ${mode}`)
        logger.debug(`Interval: ${interval}s`)
        logger.debug(`Duration: ${duration} minutes`)
      }
      
      switch (mode) {
        case 'dashboard':
          return await runDashboard(metricsCollector, healthChecker, interval, duration, logger)
          
        case 'metrics':
          return await collectMetrics(metricsCollector, interval, duration, options.export, logger)
          
        case 'health':
          return await runHealthChecks(healthChecker, interval, duration, logger)
          
        case 'alerts':
          return await manageAlerts(alertManager, logger)
          
        default:
          logger.error(`Unknown monitoring mode: ${mode}`)
          return Err(createError('INVALID_MODE', `Invalid monitoring mode: ${mode}`, {
            details: 'Valid modes are: dashboard, metrics, health, alerts'
          }))
      }
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Monitoring failed: ${errorMessage}`)
      return Err(createError('MONITOR_FAILED', `Monitoring failed: ${errorMessage}`, {
        cause: error,
        recoverable: true
      }))
    }
  }
})

/**
 * Run real-time dashboard
 */
async function runDashboard(
  metricsCollector: MetricsCollector,
  healthChecker: HealthChecker,
  interval: number,
  duration: number,
  logger: any
): Promise<Result<void>> {
  try {
    // Setup health checks
    healthChecker.register(builtInHealthChecks.memory())
    healthChecker.register(builtInHealthChecks.disk())
    healthChecker.register(builtInHealthChecks.network())
    
    // Start metrics collection
    await metricsCollector.start()
    
    let running = true
    let iterations = 0
    const maxIterations = duration > 0 ? Math.floor((duration * 60) / interval) : Infinity
    
    // Handle graceful shutdown
    process.on('SIGINT', () => {
      running = false
      logger.info('Stopping dashboard...')
    })
    
    while (running && iterations < maxIterations) {
      try {
        // Clear console and show header
        console.clear()
        console.log('üîç {{projectName}} - Real-time Dashboard')
        console.log('=====================================\\n')
        
        // Get current metrics
        const metrics = metricsCollector.getMetrics()
        const healthResults = await healthChecker.checkAll()
        
        // Display metrics
        console.log('üìä System Metrics:')
        if (metrics.length > 0) {
          metrics.forEach(metric => {
            console.log(`   ${metric.name}: ${metric.value}`)
          })
        } else {
          console.log('   No metrics available')
        }
        console.log('')
        
        // Display health status
        console.log('üíö Health Status:')
        if (healthResults.success) {
          healthResults.value.forEach(result => {
            const icon = result.status === 'healthy' ? '‚úÖ' : '‚ùå'
            console.log(`   ${icon} ${result.name}: ${result.message || result.status}`)
          })
        } else {
          console.log('   ‚ùå Health check failed')
        }
        
        console.log('\\nüïê Last updated:', new Date().toLocaleTimeString())
        console.log('Press Ctrl+C to stop monitoring\\n')
        
        // Wait for next iteration
        await new Promise(resolve => setTimeout(resolve, interval * 1000))
        iterations++
        
      } catch (error) {
        console.error('Dashboard update failed:', error)
        await new Promise(resolve => setTimeout(resolve, interval * 1000))
      }
    }
    
    // Stop metrics collection
    await metricsCollector.stop()
    
    logger.success('Dashboard monitoring completed')
    return Ok(undefined)
    
  } catch (error) {
    return Err(createError('DASHBOARD_FAILED', 'Dashboard monitoring failed', {
      cause: error,
      recoverable: true
    }))
  }
}

/**
 * Collect and export metrics
 */
async function collectMetrics(
  metricsCollector: MetricsCollector,
  interval: number,
  duration: number,
  exportFormat: string | undefined,
  logger: any
): Promise<Result<void>> {
  try {
    logger.info('Starting metrics collection...')
    
    await metricsCollector.start()
    
    // Collect for specified duration
    if (duration > 0) {
      await new Promise(resolve => setTimeout(resolve, duration * 60 * 1000))
    } else {
      // Collect for one interval
      await new Promise(resolve => setTimeout(resolve, interval * 1000))
    }
    
    await metricsCollector.stop()
    
    // Export metrics
    if (exportFormat) {
      await metricsCollector.export()
      logger.info(`Metrics exported in ${exportFormat} format`)
    } else {
      const metrics = metricsCollector.getMetrics()
      console.log('\\nCollected Metrics:')
      console.log(JSON.stringify(metrics, null, 2))
    }
    
    logger.success('Metrics collection completed')
    return Ok(undefined)
    
  } catch (error) {
    return Err(createError('METRICS_COLLECTION_FAILED', 'Metrics collection failed', {
      cause: error,
      recoverable: true
    }))
  }
}

/**
 * Run health checks
 */
async function runHealthChecks(
  healthChecker: HealthChecker,
  interval: number,
  duration: number,
  logger: any
): Promise<Result<void>> {
  try {
    logger.info('Running health checks...')
    
    // Register built-in health checks
    healthChecker.register(builtInHealthChecks.memory())
    healthChecker.register(builtInHealthChecks.disk())
    healthChecker.register(builtInHealthChecks.network())
    
    // Run health checks
    const results = await healthChecker.checkAll()
    
    if (results.success) {
      const summary = healthChecker.getSummary()
      
      logger.info(`Health check summary: ${summary.status}`)
      logger.info(`Total checks: ${summary.total}`)
      logger.info(`Healthy: ${summary.healthy}`)
      logger.info(`Degraded: ${summary.degraded}`)
      logger.info(`Unhealthy: ${summary.unhealthy}`)
      
      // Display individual results
      results.value.forEach(result => {
        const statusIcon = result.status === 'healthy' ? '‚úÖ' : 
                          result.status === 'degraded' ? '‚ö†Ô∏è' : '‚ùå'
        logger.info(`${statusIcon} ${result.name}: ${result.message || result.status} (${result.duration}ms)`)
      })
      
      logger.success('Health checks completed')
      return Ok(undefined)
      
    } else {
      logger.error('Health checks failed')
      return results
    }
    
  } catch (error) {
    return Err(createError('HEALTH_CHECK_FAILED', 'Health check execution failed', {
      cause: error,
      recoverable: true
    }))
  }
}

/**
 * Manage alerts
 */
async function manageAlerts(
  alertManager: AlertManager,
  logger: any
): Promise<Result<void>> {
  try {
    logger.info('Alert management mode')
    
    // Setup built-in alert rules
    alertManager.addRule(builtInAlertRules.highMemoryUsage())
    alertManager.addRule(builtInAlertRules.longRunningProcess())
    
    // Add console alert channel
    alertManager.addChannel({
      name: 'console',
      type: 'console',
      config: {},
      enabled: true
    })
    
    const action = await select({
      message: 'Select alert action:',
      choices: [
        { name: 'Evaluate current alerts', value: 'evaluate' },
        { name: 'View alert statistics', value: 'stats' },
        { name: 'List active alerts', value: 'list' }
      ]
    })
    
    switch (action) {
      case 'evaluate':
        const alerts = await alertManager.evaluate({})
        if (alerts.success) {
          logger.info(`Evaluated ${alerts.value.length} alerts`)
          alerts.value.forEach(alert => {
            logger.info(`üö® ${alert.name}: ${alert.message}`)
          })
        }
        break
        
      case 'stats':
        const stats = alertManager.getStats()
        logger.info('Alert Statistics:')
        logger.info(`Total: ${stats.total}`)
        logger.info(`Firing: ${stats.firing}`)
        logger.info(`Resolved: ${stats.resolved}`)
        logger.info(`By severity: ${JSON.stringify(stats.bySeverity)}`)
        break
        
      case 'list':
        const activeAlerts = alertManager.getAlerts('firing')
        logger.info(`Active alerts: ${activeAlerts.length}`)
        activeAlerts.forEach(alert => {
          logger.info(`üîî ${alert.name} (${alert.severity}): ${alert.message}`)
        })
        break
    }
    
    logger.success('Alert management completed')
    return Ok(undefined)
    
  } catch (error) {
    return Err(createError('ALERT_MANAGEMENT_FAILED', 'Alert management failed', {
      cause: error,
      recoverable: true
    }))
  }
}