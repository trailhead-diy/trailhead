import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { createTestContext } from '@esteban-url/trailhead-cli/testing'
import { monitorCommand } from '../monitor.js'

// Mock inquirer prompts
vi.mock('@inquirer/prompts', () => ({
  select: vi.fn(),
  confirm: vi.fn()
}))

// Mock monitoring classes
vi.mock('../monitoring/metrics.js', () => ({
  MetricsCollector: vi.fn()
}))

vi.mock('../monitoring/health.js', () => ({
  HealthChecker: vi.fn()
}))

vi.mock('../monitoring/alerts.js', () => ({
  AlertManager: vi.fn()
}))

// Mock fs/promises for file operations
vi.mock('fs/promises', () => ({
  writeFile: vi.fn()
}))

describe('monitor command', () => {
  let testContext: any
  let mockMetricsCollector: any
  let mockHealthChecker: any
  let mockAlertManager: any
  let mockSelect: any
  let mockConfirm: any
  let mockWriteFile: any

  // Store original console methods
  const originalConsole = {
    clear: console.clear,
    log: console.log
  }

  beforeEach(() => {
    vi.clearAllMocks()
    
    testContext = createTestContext({
      verbose: false
    })

    // Mock console methods
    console.clear = vi.fn()
    console.log = vi.fn()

    // Setup monitoring mocks
    mockMetricsCollector = {
      collect: vi.fn().mockResolvedValue({
        cpu: 45.2,
        memory: { used: 1024 * 1024 * 512, total: 1024 * 1024 * 1024 },
        disk: { used: 1024 * 1024 * 1024 * 50, total: 1024 * 1024 * 1024 * 100 },
        network: { upload: 1024 * 10, download: 1024 * 20 }
      })
    }

    mockHealthChecker = {
      checkAll: vi.fn().mockResolvedValue({
        database: { healthy: true, message: 'Connection OK' },
        redis: { healthy: false, message: 'Connection timeout' },
        api: { healthy: true, message: 'Responding normally' }
      })
    }

    mockAlertManager = {
      getActiveAlerts: vi.fn().mockResolvedValue([]),
      sendTestAlert: vi.fn().mockResolvedValue(undefined)
    }

    // Setup prompt mocks
    mockSelect = vi.fn()
    mockConfirm = vi.fn()
    mockWriteFile = vi.fn()

    // Replace mocked modules
    const inquirerModule = vi.mocked(await import('@inquirer/prompts'))
    const MetricsCollectorClass = vi.mocked(await import('../monitoring/metrics.js')).MetricsCollector
    const HealthCheckerClass = vi.mocked(await import('../monitoring/health.js')).HealthChecker
    const AlertManagerClass = vi.mocked(await import('../monitoring/alerts.js')).AlertManager
    const fsModule = vi.mocked(await import('fs/promises'))

    inquirerModule.select.mockImplementation(mockSelect)
    inquirerModule.confirm.mockImplementation(mockConfirm)
    MetricsCollectorClass.mockImplementation(() => mockMetricsCollector)
    HealthCheckerClass.mockImplementation(() => mockHealthChecker)
    AlertManagerClass.mockImplementation(() => mockAlertManager)
    fsModule.writeFile.mockImplementation(mockWriteFile)
  })

  afterEach(() => {
    // Restore console methods
    console.clear = originalConsole.clear
    console.log = originalConsole.log
    
    // Clear any remaining timers
    vi.clearAllTimers()
    
    // Remove process listeners to prevent interference
    process.removeAllListeners('SIGINT')
  })

  it('should start monitoring with dashboard mode', async () => {
    mockSelect.mockResolvedValue('dashboard')
    
    // Mock setTimeout to prevent infinite loop
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({}, testContext)
    
    // Let the dashboard run once
    await vi.advanceTimersByTimeAsync(1000)
    
    // Simulate SIGINT to stop the dashboard
    process.emit('SIGINT')
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('Starting monitoring session...')
    expect(mockSelect).toHaveBeenCalledWith({
      message: 'Select monitoring mode:',
      choices: expect.arrayContaining([
        { name: 'Real-time dashboard', value: 'dashboard' }
      ])
    })
    
    vi.useRealTimers()
  })

  it('should collect metrics with specified mode', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'metrics',
      duration: 0.01 // 0.6 seconds for quick test
    }, testContext)
    
    // Let metrics collection run
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(mockMetricsCollector.collect).toHaveBeenCalled()
    expect(testContext.logger.info).toHaveBeenCalledWith('Starting metrics collection...')
    
    vi.useRealTimers()
  })

  it('should run health checks', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'health',
      duration: 0.01 // 0.6 seconds for quick test
    }, testContext)
    
    // Let health checks run
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(mockHealthChecker.checkAll).toHaveBeenCalled()
    expect(testContext.logger.info).toHaveBeenCalledWith('Starting health checks...')
    
    vi.useRealTimers()
  })

  it('should manage alerts', async () => {
    mockSelect
      .mockResolvedValueOnce('alerts') // mode selection
      .mockResolvedValueOnce('view')   // alert action

    const result = await monitorCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(mockAlertManager.getActiveAlerts).toHaveBeenCalled()
    expect(testContext.logger.info).toHaveBeenCalledWith('Alert management interface')
  })

  it('should export metrics in JSON format', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'metrics',
      export: 'json',
      duration: 0.01
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringMatching(/metrics-\d+\.json/),
      expect.stringContaining('"cpu": 45.2')
    )
    
    vi.useRealTimers()
  })

  it('should export metrics in CSV format', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'metrics',
      export: 'csv',
      duration: 0.01
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringMatching(/metrics-\d+\.csv/),
      expect.stringContaining('cpu,memory,disk,network,timestamp')
    )
    
    vi.useRealTimers()
  })

  it('should export metrics in Prometheus format', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'metrics',
      export: 'prometheus',
      duration: 0.01
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringMatching(/metrics-\d+\.prometheus/),
      expect.stringContaining('cpu_usage 45.2')
    )
    
    vi.useRealTimers()
  })

  it('should handle custom interval and duration', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'metrics',
      interval: 5,    // 5 seconds
      duration: 0.01  // 0.6 seconds
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(6000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('Starting metrics collection...')
    
    vi.useRealTimers()
  })

  it('should display verbose debug information', async () => {
    testContext.verbose = true
    
    const result = await monitorCommand.execute({ 
      mode: 'alerts'
    }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.debug).toHaveBeenCalledWith(
      expect.stringContaining('Mode: alerts')
    )
  })

  it('should handle alert viewing with active alerts', async () => {
    mockSelect
      .mockResolvedValueOnce('alerts')
      .mockResolvedValueOnce('view')
    
    mockAlertManager.getActiveAlerts.mockResolvedValue([
      { severity: 'high', message: 'CPU usage critical' },
      { severity: 'medium', message: 'Memory usage warning' }
    ])

    const result = await monitorCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('2 active alerts:')
    expect(testContext.logger.warn).toHaveBeenCalledWith('âš ï¸  high: CPU usage critical')
  })

  it('should handle alert testing', async () => {
    mockSelect
      .mockResolvedValueOnce('alerts')
      .mockResolvedValueOnce('test')
    mockConfirm.mockResolvedValue(true)

    const result = await monitorCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(mockAlertManager.sendTestAlert).toHaveBeenCalled()
    expect(testContext.logger.info).toHaveBeenCalledWith('Test alert sent')
  })

  it('should handle declined alert testing', async () => {
    mockSelect
      .mockResolvedValueOnce('alerts')
      .mockResolvedValueOnce('test')
    mockConfirm.mockResolvedValue(false)

    const result = await monitorCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(mockAlertManager.sendTestAlert).not.toHaveBeenCalled()
  })

  it('should handle invalid monitoring mode', async () => {
    const result = await monitorCommand.execute({ 
      mode: 'invalid-mode'
    }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Unknown monitoring mode: invalid-mode')
  })

  it('should handle dashboard display correctly', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'dashboard',
      duration: 0.01
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(console.clear).toHaveBeenCalled()
    expect(console.log).toHaveBeenCalledWith('ðŸ” {{projectName}} - Real-time Dashboard')
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('ðŸ“Š System Metrics:'))
    
    vi.useRealTimers()
  })

  it('should handle health check errors correctly', async () => {
    vi.useFakeTimers()
    
    const commandPromise = monitorCommand.execute({ 
      mode: 'health',
      duration: 0.01
    }, testContext)
    
    await vi.advanceTimersByTimeAsync(1000)
    
    const result = await commandPromise
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('âœ… database: Connection OK')
    expect(testContext.logger.error).toHaveBeenCalledWith('âŒ redis: Connection timeout')
    
    vi.useRealTimers()
  })

  it('should handle unexpected errors', async () => {
    mockMetricsCollector.collect.mockRejectedValue(new Error('Metrics error'))

    const result = await monitorCommand.execute({ mode: 'dashboard' }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Monitoring failed: Metrics error')
  })

  it('should handle unimplemented alert actions', async () => {
    mockSelect
      .mockResolvedValueOnce('alerts')
      .mockResolvedValueOnce('configure')

    const result = await monitorCommand.execute({}, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.info).toHaveBeenCalledWith('configure functionality not implemented in this example')
  })
})