import { describe, it, expect, beforeEach, vi } from 'vitest'
import { createTestContext } from '@esteban-url/trailhead-cli/testing'
import { securityCommand } from '../security.js'

// Mock inquirer prompts
vi.mock('@inquirer/prompts', () => ({
  select: vi.fn(),
  confirm: vi.fn(),
  input: vi.fn()
}))

// Mock security classes
vi.mock('../security/scanner.js', () => ({
  SecurityScanner: vi.fn()
}))

vi.mock('../security/vulnerability.js', () => ({
  VulnerabilityChecker: vi.fn()
}))

vi.mock('../security/compliance.js', () => ({
  ComplianceChecker: vi.fn()
}))

vi.mock('../security/audit.js', () => ({
  AuditLogger: vi.fn()
}))

// Mock fs/promises for report generation
vi.mock('fs/promises', () => ({
  writeFile: vi.fn()
}))

describe('security command', () => {
  let testContext: any
  let mockScanner: any
  let mockVulnerabilityChecker: any
  let mockComplianceChecker: any
  let mockAuditLogger: any
  let mockSelect: any
  let mockConfirm: any
  let mockWriteFile: any

  const mockSecurityIssues = [
    {
      id: 'SEC-001',
      title: 'SQL Injection vulnerability',
      severity: 'critical',
      description: 'Potential SQL injection in user input handling',
      file: 'src/database.ts',
      line: 42,
      fixable: true,
      cve: 'CVE-2023-1234'
    },
    {
      id: 'SEC-002',
      title: 'Weak cryptographic algorithm',
      severity: 'high',
      description: 'Using MD5 for password hashing',
      file: 'src/auth.ts',
      line: 15,
      fixable: true
    },
    {
      id: 'SEC-003',
      title: 'Missing input validation',
      severity: 'medium',
      description: 'User input not properly validated',
      file: 'src/api.ts',
      line: 28,
      fixable: false
    }
  ]

  beforeEach(() => {
    vi.clearAllMocks()
    
    testContext = createTestContext({
      verbose: false
    })

    // Setup security service mocks
    mockScanner = {
      scanSourceCode: vi.fn().mockResolvedValue([mockSecurityIssues[1]]),
      scanConfiguration: vi.fn().mockResolvedValue([mockSecurityIssues[2]])
    }

    mockVulnerabilityChecker = {
      scanDependencies: vi.fn().mockResolvedValue([mockSecurityIssues[0]])
    }

    mockComplianceChecker = {
      checkCompliance: vi.fn().mockResolvedValue({
        standard: 'gdpr',
        compliant: true,
        violations: [],
        score: 95
      })
    }

    mockAuditLogger = {
      logSecurityEvent: vi.fn().mockResolvedValue(undefined)
    }

    // Setup prompt mocks
    mockSelect = vi.fn()
    mockConfirm = vi.fn()
    mockWriteFile = vi.fn()

    // Replace mocked modules
    const inquirerModule = vi.mocked(await import('@inquirer/prompts'))
    const SecurityScannerClass = vi.mocked(await import('../security/scanner.js')).SecurityScanner
    const VulnerabilityCheckerClass = vi.mocked(await import('../security/vulnerability.js')).VulnerabilityChecker
    const ComplianceCheckerClass = vi.mocked(await import('../security/compliance.js')).ComplianceChecker
    const AuditLoggerClass = vi.mocked(await import('../security/audit.js')).AuditLogger
    const fsModule = vi.mocked(await import('fs/promises'))

    inquirerModule.select.mockImplementation(mockSelect)
    inquirerModule.confirm.mockImplementation(mockConfirm)
    SecurityScannerClass.mockImplementation(() => mockScanner)
    VulnerabilityCheckerClass.mockImplementation(() => mockVulnerabilityChecker)
    ComplianceCheckerClass.mockImplementation(() => mockComplianceChecker)
    AuditLoggerClass.mockImplementation(() => mockAuditLogger)
    fsModule.writeFile.mockImplementation(mockWriteFile)
  })

  it('should run comprehensive security scan', async () => {
    const result = await securityCommand.execute({ scan: 'all' }, testContext)
    
    expect(result.success).toBe(false) // Fails due to critical/high issues
    expect(testContext.logger.info).toHaveBeenCalledWith('Starting security analysis...')
    expect(mockVulnerabilityChecker.scanDependencies).toHaveBeenCalled()
    expect(mockScanner.scanSourceCode).toHaveBeenCalled()
    expect(mockScanner.scanConfiguration).toHaveBeenCalled()
    expect(mockAuditLogger.logSecurityEvent).toHaveBeenCalledTimes(2) // start and end
  })

  it('should scan dependencies only', async () => {
    const result = await securityCommand.execute({ scan: 'deps' }, testContext)
    
    expect(result.success).toBe(false) // Critical issue found
    expect(mockVulnerabilityChecker.scanDependencies).toHaveBeenCalled()
    expect(mockScanner.scanSourceCode).not.toHaveBeenCalled()
    expect(mockScanner.scanConfiguration).not.toHaveBeenCalled()
  })

  it('should scan source code only', async () => {
    const result = await securityCommand.execute({ scan: 'code' }, testContext)
    
    expect(result.success).toBe(false) // High severity issue
    expect(mockScanner.scanSourceCode).toHaveBeenCalled()
    expect(mockVulnerabilityChecker.scanDependencies).not.toHaveBeenCalled()
    expect(mockScanner.scanConfiguration).not.toHaveBeenCalled()
  })

  it('should scan configuration only', async () => {
    const result = await securityCommand.execute({ scan: 'config' }, testContext)
    
    expect(result.success).toBe(true) // Only medium severity issue
    expect(mockScanner.scanConfiguration).toHaveBeenCalled()
    expect(mockVulnerabilityChecker.scanDependencies).not.toHaveBeenCalled()
    expect(mockScanner.scanSourceCode).not.toHaveBeenCalled()
  })

  it('should prompt for scan type when not specified', async () => {
    mockSelect.mockResolvedValue('deps')
    
    const result = await securityCommand.execute({}, testContext)
    
    expect(mockSelect).toHaveBeenCalledWith({
      message: 'Select security scan type:',
      choices: expect.arrayContaining([
        { name: 'Dependency vulnerabilities', value: 'deps' }
      ])
    })
    expect(mockVulnerabilityChecker.scanDependencies).toHaveBeenCalled()
  })

  it('should filter issues by severity threshold', async () => {
    const result = await securityCommand.execute({ 
      scan: 'all',
      severity: 'high'
    }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.info).toHaveBeenCalledWith('  ðŸ” Total issues: 2') // Only critical and high
  })

  it('should run compliance check when specified', async () => {
    const result = await securityCommand.execute({ 
      scan: 'deps',
      compliance: 'gdpr'
    }, testContext)
    
    expect(mockComplianceChecker.checkCompliance).toHaveBeenCalledWith('gdpr')
    expect(testContext.logger.success).toHaveBeenCalledWith('âœ… GDPR compliant (Score: 95/100)')
  })

  it('should handle non-compliant standards', async () => {
    mockComplianceChecker.checkCompliance.mockResolvedValue({
      standard: 'sox',
      compliant: false,
      violations: [
        { rule: 'SOX-001', description: 'Missing audit trail', severity: 'high' }
      ],
      score: 60
    })

    const result = await securityCommand.execute({ 
      scan: 'config',
      compliance: 'sox'
    }, testContext)
    
    expect(testContext.logger.error).toHaveBeenCalledWith('âŒ SOX non-compliant (Score: 60/100)')
    expect(testContext.logger.error).toHaveBeenCalledWith('Found 1 violations')
  })

  it('should offer to apply fixes when fix flag is set', async () => {
    mockConfirm.mockResolvedValue(true)
    
    const result = await securityCommand.execute({ 
      scan: 'all',
      fix: true
    }, testContext)
    
    expect(mockConfirm).toHaveBeenCalledWith({
      message: 'Apply automatic fixes for 2 issues?',
      default: false
    })
    expect(testContext.logger.info).toHaveBeenCalledWith('Fixed 2/2 issues')
  })

  it('should skip fixes when user declines', async () => {
    mockConfirm.mockResolvedValue(false)
    
    const result = await securityCommand.execute({ 
      scan: 'deps',
      fix: true
    }, testContext)
    
    expect(mockConfirm).toHaveBeenCalled()
    expect(testContext.logger.info).not.toHaveBeenCalledWith(expect.stringContaining('Fixed'))
  })

  it('should generate JSON security report', async () => {
    const result = await securityCommand.execute({ 
      scan: 'config',
      report: 'json'
    }, testContext)
    
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringMatching(/security-report-.*\.json/),
      expect.stringContaining('"issues"')
    )
    expect(testContext.logger.success).toHaveBeenCalledWith(
      expect.stringMatching(/Security report generated: security-report-.*\.json/)
    )
  })

  it('should generate HTML security report', async () => {
    const result = await securityCommand.execute({ 
      scan: 'code',
      report: 'html'
    }, testContext)
    
    expect(mockWriteFile).toHaveBeenCalledWith(
      expect.stringMatching(/security-report-.*\.html/),
      expect.stringContaining('<!DOCTYPE html>')
    )
  })

  it('should warn about unsupported PDF generation', async () => {
    const result = await securityCommand.execute({ 
      scan: 'config',
      report: 'pdf'
    }, testContext)
    
    expect(testContext.logger.warn).toHaveBeenCalledWith('PDF generation not implemented in this example')
  })

  it('should handle unsupported report formats', async () => {
    const result = await securityCommand.execute({ 
      scan: 'config',
      report: 'xml'
    }, testContext)
    
    expect(testContext.logger.error).toHaveBeenCalledWith('Unsupported report format: xml')
  })

  it('should display detailed security summary', async () => {
    const result = await securityCommand.execute({ scan: 'all' }, testContext)
    
    expect(testContext.logger.info).toHaveBeenCalledWith('Security Scan Summary:')
    expect(testContext.logger.info).toHaveBeenCalledWith('  ðŸ” Total issues: 3')
    expect(testContext.logger.error).toHaveBeenCalledWith('  ðŸš¨ Critical: 1')
    expect(testContext.logger.error).toHaveBeenCalledWith('  âš ï¸  High: 1')
    expect(testContext.logger.warn).toHaveBeenCalledWith('  ðŸ“‹ Medium: 1')
  })

  it('should pass with only low severity issues', async () => {
    // Mock only low severity issues
    mockVulnerabilityChecker.scanDependencies.mockResolvedValue([])
    mockScanner.scanSourceCode.mockResolvedValue([])
    mockScanner.scanConfiguration.mockResolvedValue([
      { ...mockSecurityIssues[2], severity: 'low' }
    ])

    const result = await securityCommand.execute({ scan: 'all' }, testContext)
    
    expect(result.success).toBe(true)
    expect(testContext.logger.success).toHaveBeenCalledWith('Security scan completed successfully')
  })

  it('should log verbose debug information', async () => {
    testContext.verbose = true
    
    const result = await securityCommand.execute({ 
      scan: 'code',
      severity: 'low',
      fix: false
    }, testContext)
    
    expect(testContext.logger.debug).toHaveBeenCalledWith(
      'Scan type: code, Min severity: low, Auto-fix: false'
    )
  })

  it('should handle scanner errors gracefully', async () => {
    mockVulnerabilityChecker.scanDependencies.mockRejectedValue(new Error('Scanner error'))
    
    const result = await securityCommand.execute({ scan: 'deps' }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.error).toHaveBeenCalledWith('Security scan failed: Scanner error')
  })

  it('should handle fix application errors', async () => {
    mockConfirm.mockResolvedValue(true)
    
    // Mock a fix failure by modifying the setTimeout to throw
    const originalSetTimeout = global.setTimeout
    global.setTimeout = vi.fn().mockImplementation((fn) => {
      throw new Error('Fix failed')
    })

    const result = await securityCommand.execute({ 
      scan: 'deps',
      fix: true
    }, testContext)
    
    expect(result.success).toBe(false)
    expect(testContext.logger.info).toHaveBeenCalledWith('Fixed 0/1 issues')
    
    global.setTimeout = originalSetTimeout
  })

  it('should handle report generation errors', async () => {
    mockWriteFile.mockRejectedValue(new Error('Write failed'))
    
    const result = await securityCommand.execute({ 
      scan: 'config',
      report: 'json'
    }, testContext)
    
    expect(testContext.logger.error).toHaveBeenCalledWith('Failed to generate report: Error: Write failed')
  })

  it('should use security command alias', async () => {
    // Test that the command has the 'sec' alias
    expect(securityCommand.aliases).toContain('sec')
  })

  it('should log audit events properly', async () => {
    const result = await securityCommand.execute({ scan: 'deps' }, testContext)
    
    expect(mockAuditLogger.logSecurityEvent).toHaveBeenCalledWith({
      type: 'security_scan_initiated',
      user: expect.any(String),
      timestamp: expect.any(Date),
      details: { options: { scan: 'deps' } }
    })
    
    expect(mockAuditLogger.logSecurityEvent).toHaveBeenCalledWith({
      type: 'security_scan_completed',
      user: expect.any(String),
      timestamp: expect.any(Date),
      details: expect.objectContaining({
        issues: 1,
        critical: 1
      })
    })
  })
})