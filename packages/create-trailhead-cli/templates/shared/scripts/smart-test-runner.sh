#!/bin/bash
# smart-test-runner.sh v1.0.0
# Generated by @esteban-url/trailhead-cli
# Intelligent test execution for git pre-commit hooks

set -euo pipefail

SCRIPT_VERSION="1.0.0"
CLI_VERSION="{{CLI_VERSION}}"

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CONFIG_FILE=".smart-test-config.json"
DRY_RUN=false
VERBOSE=false
FORCE_TESTS=false
SKIP_TESTS=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --force)
      FORCE_TESTS=true
      shift
      ;;
    --skip)
      SKIP_TESTS=true
      shift
      ;;
    --help)
      echo "Usage: $0 [--dry-run] [--verbose] [--force] [--skip] [--help]"
      echo ""
      echo "Options:"
      echo "  --dry-run    Show what would be executed without running tests"
      echo "  --verbose    Show detailed information about file detection"
      echo "  --force      Force full test suite execution"
      echo "  --skip       Skip all test execution"
      echo "  --help       Show this help message"
      echo ""
      echo "Environment variables:"
      echo "  FORCE_TESTS=1    Force full test suite execution"
      echo "  SKIP_TESTS=1     Skip all test execution"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Check environment variables
if [[ "${FORCE_TESTS:-}" == "1" ]]; then
  FORCE_TESTS=true
fi

if [[ "${SKIP_TESTS:-}" == "1" ]]; then
  SKIP_TESTS=true
fi

# Logging functions
log_info() {
  echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
  echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
  echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
  echo -e "${RED}âŒ $1${NC}"
}

log_verbose() {
  if [[ "$VERBOSE" == "true" ]]; then
    echo -e "${BLUE}ðŸ” $1${NC}" >&2
  fi
}

# Load configuration
has_config() {
  [[ -f "$CONFIG_FILE" ]] && command -v jq &> /dev/null
}

# Get staged files
get_staged_files() {
  git diff --cached --name-only 2>/dev/null || echo ""
}

# Get configuration value with fallback
get_config_value() {
  local key="$1"
  local default="$2"
  
  if has_config; then
    jq -r "$key // \"$default\"" "$CONFIG_FILE" 2>/dev/null || echo "$default"
  else
    echo "$default"
  fi
}

# Check if files match patterns
files_match_pattern() {
  local files="$1"
  local pattern="$2"
  
  if [[ -z "$files" ]] || [[ -z "$pattern" ]]; then
    return 1
  fi
  
  echo "$files" | grep -qE "$pattern"
}

# Detect test framework
detect_test_framework() {
  if [[ -f "vitest.config.ts" ]] || [[ -f "vitest.config.js" ]]; then
    echo "vitest"
  elif [[ -f "jest.config.js" ]] || [[ -f "jest.config.ts" ]]; then
    echo "jest"
  elif grep -q "vitest" package.json 2>/dev/null; then
    echo "vitest"
  elif grep -q "jest" package.json 2>/dev/null; then
    echo "jest"
  else
    echo "unknown"
  fi
}

# Detect package manager
detect_package_manager() {
  if [[ -f "pnpm-lock.yaml" ]]; then
    echo "{{PACKAGE_MANAGER}}"
  elif [[ -f "yarn.lock" ]]; then
    echo "yarn"
  elif [[ -f "package-lock.json" ]]; then
    echo "npm"
  else
    echo "{{PACKAGE_MANAGER}}"
  fi
}

# Detect monorepo structure
detect_monorepo() {
  {{#if IS_MONOREPO}}
  echo "true"
  {{else}}
  if [[ -f "pnpm-workspace.yaml" ]] || [[ -f "turbo.json" ]] || [[ -f "lerna.json" ]]; then
    echo "true"
  else
    echo "false"
  fi
  {{/if}}
}

# Get default test command
get_default_test_command() {
  echo "{{TEST_COMMAND}}"
}

# Detect file risk level
detect_risk_level() {
  local staged_files="$1"
  
  log_verbose "Analyzing $(echo "$staged_files" | wc -l) staged files"
  
  # High-risk patterns
  local high_risk_patterns
  if has_config; then
    high_risk_patterns=$(jq -r '.highRiskPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$high_risk_patterns" ]]; then
    high_risk_patterns="{{#each HIGH_RISK_PATTERNS}}{{this}}{{#unless @last}}|{{/unless}}{{/each}}"
  fi
  
  # Skip patterns  
  local skip_patterns
  if has_config; then
    skip_patterns=$(jq -r '.skipPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$skip_patterns" ]]; then
    skip_patterns="{{#each SKIP_PATTERNS}}{{this}}{{#unless @last}}|{{/unless}}{{/each}}"
  fi
  
  log_verbose "High-risk patterns: $high_risk_patterns"
  log_verbose "Skip patterns: $skip_patterns"
  
  # Check for high-risk files
  if files_match_pattern "$staged_files" "$high_risk_patterns"; then
    log_verbose "Found high-risk files"
    echo "high"
    return 0
  fi
  
  # Check if all files match skip patterns first
  local non_skip_files
  non_skip_files=$(echo "$staged_files" | grep -vE "$skip_patterns" || echo "")
  
  if [[ -z "$non_skip_files" ]]; then
    log_verbose "All files match skip patterns"
    echo "skip"
    return 0
  fi
  
  # Check for package-specific changes (monorepo)
  if [[ "$(detect_monorepo)" == "true" ]] && files_match_pattern "$non_skip_files" "{{PACKAGES_PATTERN}}"; then
    log_verbose "Found package-specific changes"
    echo "medium"
    return 0
  fi
  
  # Default to medium risk
  log_verbose "Defaulting to medium risk"
  echo "medium"
}

# Get affected packages
get_affected_packages() {
  local staged_files="$1"
  
  # Extract unique packages from staged files
  echo "$staged_files" | grep -E "{{PACKAGES_PATTERN}}" | cut -d'/' -f2 | sort -u
}

# Get package filter name
get_package_filter() {
  local package="$1"
  
  # Try to get from config first
  if has_config; then
    local filter
    filter=$(jq -r ".packageMappings.\"$package\" // \"\"" "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$filter" ]]; then
      echo "$filter"
      return 0
    fi
  fi
  
  {{#if PACKAGE_MAPPINGS}}
  # Use predefined mappings from template
  case "$package" in
    {{#each PACKAGE_MAPPINGS}}
    "{{@key}}")
      echo "{{this}}"
      return 0
      ;;
    {{/each}}
  esac
  {{/if}}
  
  # Default to package name with project scope
  echo "@{{PROJECT_NAME}}/$package"
}

# Execute tests
execute_tests() {
  local test_command="$1"
  local description="$2"
  
  log_info "$description"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "DRY RUN: Would execute: $test_command"
    return 0
  fi
  
  log_verbose "Executing: $test_command"
  
  # Get timeout from config
  local timeout
  timeout=$(get_config_value '.timeout' '{{TIMEOUT}}')
  
  # Execute with timeout
  if timeout "${timeout}s" bash -c "$test_command"; then
    log_success "Tests completed successfully"
    return 0
  else
    local exit_code=$?
    if [[ $exit_code -eq 124 ]]; then
      log_error "Tests timed out after ${timeout}s"
    else
      log_error "Tests failed with exit code $exit_code"
    fi
    return $exit_code
  fi
}

# Main execution logic
main() {
  log_info "Smart Test Runner v$SCRIPT_VERSION (generated by trailhead-cli v$CLI_VERSION)"
  
  # Check for skip flag
  if [[ "$SKIP_TESTS" == "true" ]]; then
    log_warning "Skipping all tests (SKIP_TESTS=1 or --skip)"
    return 0
  fi
  
  # Get staged files
  local staged_files
  staged_files=$(get_staged_files)
  
  if [[ -z "$staged_files" ]]; then
    log_warning "No staged files found"
    return 0
  fi
  
  log_verbose "Found $(echo "$staged_files" | wc -l) staged files"
  
  # Get test command from config or detect
  local test_command
  test_command=$(get_config_value '.testCommand' "$(get_default_test_command)")
  
  # Force full test suite if requested
  if [[ "$FORCE_TESTS" == "true" ]]; then
    execute_tests "$test_command" "ðŸ”´ Forced full test suite execution"
    return $?
  fi
  
  # Detect risk level
  local risk_level
  risk_level=$(detect_risk_level "$staged_files")
  
  log_verbose "Detected risk level: $risk_level"
  
  case "$risk_level" in
    "high")
      execute_tests "$test_command" "ðŸ”´ Code changes detected - running full test suite"
      return $?
      ;;
    "medium")
      # Check if this is a monorepo
      if [[ "$(detect_monorepo)" == "true" ]]; then
        # Get affected packages
        local affected_packages
        affected_packages=$(get_affected_packages "$staged_files")
        
        if [[ -z "$affected_packages" ]]; then
          log_warning "Package changes detected but no packages identified, running full test suite"
          execute_tests "$test_command" "ðŸŸ¡ Running full test suite (package detection failed)"
          return $?
        fi
        
        log_info "ðŸŸ¡ Package changes detected - running affected tests"
        
        # Run tests for each affected package
        local overall_exit_code=0
        local pm
        pm=$(detect_package_manager)
        
        while IFS= read -r package; do
          if [[ -n "$package" ]]; then
            local package_filter
            package_filter=$(get_package_filter "$package")
            
            local package_test_command
            if [[ "$pm" == "pnpm" ]]; then
              package_test_command="$test_command --filter=$package_filter"
            else
              # For non-pnpm, try to cd into package directory
              if [[ -d "{{PACKAGES_DIR}}/$package" ]]; then
                package_test_command="cd {{PACKAGES_DIR}}/$package && $test_command"
              else
                package_test_command="$test_command"
              fi
            fi
            
            if ! execute_tests "$package_test_command" "Testing package: $package ($package_filter)"; then
              overall_exit_code=$?
            fi
          fi
        done <<< "$affected_packages"
        
        return $overall_exit_code
      else
        # Single package project
        execute_tests "$test_command" "ðŸŸ¡ Running test suite for medium-risk changes"
        return $?
      fi
      ;;
    "skip")
      log_success "ðŸŸ¢ Documentation/config changes only - skipping tests"
      return 0
      ;;
    *)
      log_warning "Unknown risk level: '$risk_level', running full test suite"
      execute_tests "$test_command" "ðŸŸ¡ Running full test suite (unknown risk level)"
      return $?
      ;;
  esac
}

# Run main function
main "$@"