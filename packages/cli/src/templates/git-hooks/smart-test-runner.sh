#!/bin/bash
# smart-test-runner.sh v1.1.0
# Generated by @esteban-url/trailhead-cli
# Intelligent test execution for git pre-commit hooks

set -euo pipefail

SCRIPT_VERSION="1.1.0"
CLI_VERSION="{{CLI_VERSION}}"

# Cache variables
STAGED_FILES_CACHE=""
CACHE_TIMESTAMP=0

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CONFIG_FILE=".smart-test-config.json"
DRY_RUN=false
VERBOSE=false
FORCE_TESTS=false
SKIP_TESTS=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --force)
      FORCE_TESTS=true
      shift
      ;;
    --skip)
      SKIP_TESTS=true
      shift
      ;;
    --help)
      echo "Usage: $0 [--dry-run] [--verbose] [--force] [--skip] [--help]"
      echo ""
      echo "Options:"
      echo "  --dry-run    Show what would be executed without running tests"
      echo "  --verbose    Show detailed information about file detection"
      echo "  --force      Force full test suite execution"
      echo "  --skip       Skip all test execution"
      echo "  --help       Show this help message"
      echo ""
      echo "Environment variables:"
      echo "  FORCE_TESTS=1    Force full test suite execution"
      echo "  SKIP_TESTS=1     Skip all test execution"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Check environment variables
if [[ "${FORCE_TESTS:-}" == "1" ]]; then
  FORCE_TESTS=true
fi

if [[ "${SKIP_TESTS:-}" == "1" ]]; then
  SKIP_TESTS=true
fi

# Logging functions
log_info() {
  echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

log_success() {
  echo -e "${GREEN}âœ… $1${NC}"
}

log_warning() {
  echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_error() {
  echo -e "${RED}âŒ $1${NC}"
}

log_verbose() {
  if [[ "$VERBOSE" == "true" ]]; then
    echo -e "${BLUE}ðŸ” $1${NC}" >&2
  fi
}

# Load configuration with graceful degradation
has_config() {
  [[ -f "$CONFIG_FILE" ]] && command -v jq &> /dev/null
}

has_jq() {
  command -v jq &> /dev/null
}

# Parse JSON without jq (fallback)
parse_json_fallback() {
  local key="$1"
  local default="$2"
  local file="$3"
  
  if [[ ! -f "$file" ]]; then
    echo "$default"
    return
  fi
  
  # Simple pattern matching for basic JSON values
  case "$key" in
    ".timeout")
      grep -o '"timeout"[[:space:]]*:[[:space:]]*[0-9]*' "$file" | grep -o '[0-9]*' || echo "$default"
      ;;
    ".parallelTesting")
      if grep -q '"parallelTesting"[[:space:]]*:[[:space:]]*true' "$file"; then
        echo "true"
      elif grep -q '"parallelTesting"[[:space:]]*:[[:space:]]*false' "$file"; then
        echo "false"
      else
        echo "$default"
      fi
      ;;
    ".testCommand")
      grep -o '"testCommand"[[:space:]]*:[[:space:]]*"[^"]*"' "$file" | sed 's/.*"\([^"]*\)".*/\1/' || echo "$default"
      ;;
    *)
      echo "$default"
      ;;
  esac
}

# Get staged files with caching
get_staged_files() {
  local current_time
  current_time=$(date +%s)
  
  # Cache for 5 seconds to avoid repeated git calls
  if [[ -n "$STAGED_FILES_CACHE" && $((current_time - CACHE_TIMESTAMP)) -lt 5 ]]; then
    echo "$STAGED_FILES_CACHE"
    return
  fi
  
  local files
  files=$(git diff --cached --name-only 2>/dev/null || echo "")
  
  STAGED_FILES_CACHE="$files"
  CACHE_TIMESTAMP="$current_time"
  
  echo "$files"
}

# Get configuration value with fallback
get_config_value() {
  local key="$1"
  local default="$2"
  
  if has_config; then
    jq -r "$key // \"$default\"" "$CONFIG_FILE" 2>/dev/null || echo "$default"
  else
    echo "$default"
  fi
}

# Check if files match patterns
files_match_pattern() {
  local files="$1"
  local pattern="$2"
  
  if [[ -z "$files" ]] || [[ -z "$pattern" ]]; then
    return 1
  fi
  
  echo "$files" | grep -qE "$pattern"
}

# Detect test framework
detect_test_framework() {
  if [[ -f "vitest.config.ts" ]] || [[ -f "vitest.config.js" ]]; then
    echo "vitest"
  elif [[ -f "jest.config.js" ]] || [[ -f "jest.config.ts" ]]; then
    echo "jest"
  elif grep -q "vitest" package.json 2>/dev/null; then
    echo "vitest"
  elif grep -q "jest" package.json 2>/dev/null; then
    echo "jest"
  else
    echo "unknown"
  fi
}

# Detect package manager
detect_package_manager() {
  if [[ -f "pnpm-lock.yaml" ]]; then
    echo "pnpm"
  elif [[ -f "yarn.lock" ]]; then
    echo "yarn"
  elif [[ -f "package-lock.json" ]]; then
    echo "npm"
  else
    echo "npm"
  fi
}

# Detect monorepo structure
detect_monorepo() {
  if [[ -f "pnpm-workspace.yaml" ]] || [[ -f "turbo.json" ]] || [[ -f "lerna.json" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

# Get default test command
get_default_test_command() {
  local pm
  pm=$(detect_package_manager)
  
  case "$pm" in
    "pnpm")
      echo "pnpm test"
      ;;
    "yarn")
      echo "yarn test"
      ;;
    "npm")
      echo "npm test"
      ;;
    *)
      echo "npm test"
      ;;
  esac
}

# Detect file risk level
detect_risk_level() {
  local staged_files="$1"
  
  log_verbose "Analyzing $(echo "$staged_files" | wc -l) staged files"
  
  # High-risk patterns
  local high_risk_patterns
  if has_config; then
    high_risk_patterns=$(jq -r '.highRiskPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$high_risk_patterns" ]]; then
    high_risk_patterns='\.(ts|tsx|js|jsx)$|tsconfig|package\.json$|{{MONOREPO_CONFIG_PATTERN}}'
  fi
  
  # Skip patterns  
  local skip_patterns
  if has_config; then
    skip_patterns=$(jq -r '.skipPatterns | join("|")' "$CONFIG_FILE" 2>/dev/null || echo "")
  fi
  
  if [[ -z "$skip_patterns" ]]; then
    skip_patterns='\.md$|README|CHANGELOG|LICENSE|\.github/'
  fi
  
  log_verbose "High-risk patterns: $high_risk_patterns"
  log_verbose "Skip patterns: $skip_patterns"
  
  # Check for high-risk files
  if files_match_pattern "$staged_files" "$high_risk_patterns"; then
    log_verbose "Found high-risk files"
    echo "high"
    return 0
  fi
  
  # Check for package-specific changes (monorepo)
  if [[ "$(detect_monorepo)" == "true" ]] && files_match_pattern "$staged_files" "^{{PACKAGES_PATTERN}}"; then
    log_verbose "Found package-specific changes"
    echo "medium"
    return 0
  fi
  
  # Check if all files match skip patterns
  local non_skip_files
  non_skip_files=$(echo "$staged_files" | grep -vE "$skip_patterns" || echo "")
  
  if [[ -z "$non_skip_files" ]]; then
    log_verbose "All files match skip patterns"
    echo "skip"
    return 0
  fi
  
  # Default to medium risk
  log_verbose "Defaulting to medium risk"
  echo "medium"
}

# Get affected packages
get_affected_packages() {
  local staged_files="$1"
  
  # Extract unique packages from staged files
  echo "$staged_files" | grep -E "^{{PACKAGES_PATTERN}}" | cut -d'/' -f2 | sort -u
}

# Get package filter name
get_package_filter() {
  local package="$1"
  
  # Try to get from config first
  if has_config; then
    local filter
    filter=$(jq -r ".packageMappings.\"$package\" // \"\"" "$CONFIG_FILE" 2>/dev/null || echo "")
    if [[ -n "$filter" ]]; then
      echo "$filter"
      return 0
    fi
  fi
  
  # Default to package name
  echo "$package"
}

# Execute tests
execute_tests() {
  local test_command="$1"
  local description="$2"
  
  log_info "$description"
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log_info "DRY RUN: Would execute: $test_command"
    return 0
  fi
  
  log_verbose "Executing: $test_command"
  
  # Get timeout from config
  local timeout
  timeout=$(get_config_value '.timeout' '120')
  
  # Execute with timeout
  if timeout "${timeout}s" bash -c "$test_command"; then
    log_success "Tests completed successfully"
    return 0
  else
    local exit_code=$?
    if [[ $exit_code -eq 124 ]]; then
      log_error "Tests timed out after ${timeout}s"
    else
      log_error "Tests failed with exit code $exit_code"
    fi
    return $exit_code
  fi
}

# Main execution logic
main() {
  log_info "Smart Test Runner v$SCRIPT_VERSION"
  
  # Check for skip flag
  if [[ "$SKIP_TESTS" == "true" ]]; then
    log_warning "Skipping all tests (SKIP_TESTS=1 or --skip)"
    return 0
  fi
  
  # Get staged files
  local staged_files
  staged_files=$(get_staged_files)
  
  if [[ -z "$staged_files" ]]; then
    log_warning "No staged files found"
    return 0
  fi
  
  log_verbose "Found $(echo "$staged_files" | wc -l) staged files"
  
  # Get test command from config or detect
  local test_command
  test_command=$(get_config_value '.testCommand' "$(get_default_test_command)")
  
  # Force full test suite if requested
  if [[ "$FORCE_TESTS" == "true" ]]; then
    execute_tests "$test_command" "ðŸ”´ Forced full test suite execution"
    return $?
  fi
  
  # Detect risk level
  local risk_level
  risk_level=$(detect_risk_level "$staged_files")
  
  log_verbose "Detected risk level: $risk_level"
  
  case "$risk_level" in
    "high")
      execute_tests "$test_command" "ðŸ”´ Code changes detected - running full test suite"
      return $?
      ;;
    "medium")
      # Check if this is a monorepo
      if [[ "$(detect_monorepo)" == "true" ]]; then
        # Get affected packages
        local affected_packages
        affected_packages=$(get_affected_packages "$staged_files")
        
        if [[ -z "$affected_packages" ]]; then
          log_warning "Package changes detected but no packages identified, running full test suite"
          execute_tests "$test_command" "ðŸŸ¡ Running full test suite (package detection failed)"
          return $?
        fi
        
        log_info "ðŸŸ¡ Package changes detected - running affected tests"
        
        # Run tests for each affected package
        local overall_exit_code=0
        local pm
        pm=$(detect_package_manager)
        
        while IFS= read -r package; do
          if [[ -n "$package" ]]; then
            local package_filter
            package_filter=$(get_package_filter "$package")
            
            local package_test_command
            if [[ "$pm" == "pnpm" ]]; then
              package_test_command="$test_command --filter=$package_filter"
            else
              # For non-pnpm, try to cd into package directory
              if [[ -d "{{PACKAGES_DIR}}/$package" ]]; then
                package_test_command="cd {{PACKAGES_DIR}}/$package && $test_command"
              else
                package_test_command="$test_command"
              fi
            fi
            
            if ! execute_tests "$package_test_command" "Testing package: $package ($package_filter)"; then
              overall_exit_code=$?
            fi
          fi
        done <<< "$affected_packages"
        
        return $overall_exit_code
      else
        # Single package project
        execute_tests "$test_command" "ðŸŸ¡ Running test suite for medium-risk changes"
        return $?
      fi
      ;;
    "skip")
      log_success "ðŸŸ¢ Documentation/config changes only - skipping tests"
      return 0
      ;;
    *)
      log_warning "Unknown risk level: '$risk_level', running full test suite"
      execute_tests "$test_command" "ðŸŸ¡ Running full test suite (unknown risk level)"
      return $?
      ;;
  esac
}

# Run main function
main "$@"