import { createCommand } from '@esteban-url/cli/command'
import type { CommandOptions } from '@esteban-url/cli/command'
import { ok, err } from '@esteban-url/core'
import type { Result, CoreError } from '@esteban-url/core'

interface BuildOptions extends CommandOptions {
  output?: string;
  watch?: boolean;
  minify?: boolean;
}

/**
 * Build Command
 * 
 * Example command that demonstrates trailhead-cli patterns:
 * - Functional command creation
 * - Result-based error handling
 * - Context usage for logging and filesystem
 */
export const buildCommand = createCommand<BuildOptions>({
  name: 'build',
  description: 'Build the project',
  options: [
    {
      flags: '-o, --output <dir>',
      description: 'Output directory',
      type: 'string',
      default: 'dist'
    },
    {
      flags: '-w, --watch',
      description: 'Watch for changes',
      type: 'boolean'
    },
    {
      flags: '--minify',
      description: 'Minify output',
      type: 'boolean'
    }
  ],
  action: async (options, context) => {
    const { logger, fs, verbose } = context
    
    try {
      logger.info('Starting build process...')
      
      if (verbose) {
        logger.debug(`Build options: production=${options.production}, watch=${options.watch}, output=${options.output || 'dist'}`)
      }
      
      // Example build logic using filesystem abstraction
      const outputDir = options.output || 'dist'
      const ensureResult = await fs.ensureDir(outputDir)
      
      if (ensureResult.isErr()) {
        logger.error(`Failed to create output directory: ${ensureResult.error.message}`)
        return ensureResult
      }
      
      // Simulate build process
      logger.info(`Building to ${outputDir}...`)
      
      if (options.watch) {
        logger.info('Watching for changes... (Press Ctrl+C to stop)')
        // Watch mode implementation would go here
      }
      
      if (options.minify) {
        logger.info('Minifying output...')
        // Minification logic would go here
      }
      
      logger.success('Build completed successfully!')
      return ok(undefined)
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Build failed: ${errorMessage}`)
      return err({
        code: 'BUILD_FAILED',
        message: `Build failed: ${errorMessage}`,
        details: {
          component: '{{packageName}}',
          operation: 'build'
        },
        cause: error instanceof Error ? error : undefined,
        suggestion: 'Check the build configuration and try again'
      } satisfies CoreError)
    }
  }
})