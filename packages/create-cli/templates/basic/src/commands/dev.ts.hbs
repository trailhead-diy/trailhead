import { createCommand } from '@esteban-url/cli/command'
import type { CommandOptions } from '@esteban-url/cli/command'
import { input, confirm } from '@esteban-url/cli/prompts'
import { ok, err } from '@esteban-url/core'
import type { Result, CoreError } from '@esteban-url/core'

interface DevOptions extends CommandOptions {
  port?: number;
  host?: string;
  open?: boolean;
  interactive?: boolean;
}

/**
 * Dev Command
 * 
 * Example development command that demonstrates:
 * - Interactive prompts
 * - Configuration loading
 * - Error handling patterns
 */
export const devCommand = createCommand<DevOptions>({
  name: 'dev',
  description: 'Start development server',
  options: [
    {
      flags: '-p, --port <number>',
      description: 'Port to serve on',
      type: 'number',
      default: 3000
    },
    {
      flags: '-h, --host <host>',
      description: 'Host to bind to',
      type: 'string',
      default: 'localhost'
    },
    {
      flags: '--open',
      description: 'Open browser automatically',
      type: 'boolean'
    },
    {
      flags: '-i, --interactive',
      description: 'Run in interactive mode',
      type: 'boolean'
    }
  ],
  action: async (options, context) => {
    const { logger, verbose } = context
    
    try {
      logger.info('Starting development server...')
      
      let port = options.port || 3000
      let host = options.host || 'localhost'
      
      // Interactive mode
      if (options.interactive) {
        logger.info('Running in interactive mode')
        
        const portInput = await input({
          message: 'Port:',
          default: String(port),
          validate: (value) => {
            const num = parseInt(value)
            return num > 0 && num < 65536 ? true : 'Port must be between 1 and 65535'
          }
        })
        port = parseInt(portInput)
        
        host = await input({
          message: 'Host:',
          default: host
        })
        
        const shouldOpen = await confirm({
          message: 'Open browser automatically?',
          default: options.open ?? false
        })
        
        // Store the result for later use
        if (shouldOpen) {
          logger.info('Browser will be opened after server starts')
        }
      }
      
      if (verbose) {
        logger.debug(`Server configuration: ${JSON.stringify({ port, host, open: options.open })}`)
      }
      
      // Validate port availability (example)
      const isPortAvailable = await checkPortAvailable(port)
      if (isPortAvailable.isErr()) {
        logger.error(`Port ${port} is already in use`)
        return isPortAvailable
      }
      
      logger.info(`Development server starting on http://${host}:${port}`)
      
      if (options.open) {
        logger.info('Opening browser...')
        // Browser opening logic would go here
      }
      
      // Simulate server startup
      logger.success('Development server is running!')
      logger.info('Press Ctrl+C to stop')
      
      return ok(undefined)
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Failed to start development server: ${errorMessage}`)
      return err({
        code: 'DEV_SERVER_FAILED',
        message: `Dev server failed: ${errorMessage}`,
        details: {
          component: '{{packageName}}',
          operation: 'dev'
        },
        cause: error instanceof Error ? error : undefined,
        suggestion: 'Check the port configuration and try again'
      } satisfies CoreError)
    }
  }
})

/**
 * Check if port is available (example utility function)
 */
async function checkPortAvailable(port: number): Promise<Result<boolean, CoreError>> {
  try {
    // This is a simplified example
    // In real implementation, you'd check if the port is actually available
    if (port < 1 || port > 65535) {
      return err({
        code: 'INVALID_PORT',
        message: 'Invalid port range',
        details: {
          component: '{{packageName}}',
          operation: 'checkPortAvailable',
          constraints: 'Port must be between 1 and 65535'
        },
        suggestion: 'Use a port between 1 and 65535'
      } satisfies CoreError)
    }
    
    return ok(true)
  } catch (error) {
    return err({
      code: 'PORT_CHECK_FAILED',
      message: 'Failed to check port availability',
      details: {
        component: '{{packageName}}',
        operation: 'checkPortAvailable'
      },
      cause: error instanceof Error ? error : undefined
    } satisfies CoreError)
  }
}