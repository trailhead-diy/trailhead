import { createCommand, type CommandOptions, type CommandContext } from '@trailhead/cli/command'
import { ok, err, createCoreError, type Result, type CoreError } from '@trailhead/core'
import { fs } from '@trailhead/fs'
import { resolve } from 'path'
import { configSchema, type Config } from '../lib/config-schema.js'

/**
 * Configuration command options
 */
interface ConfigCommandOptions extends CommandOptions {
  init?: boolean
  validate?: boolean
  show?: boolean
}

/**
 * Configuration management command
 *
 * Demonstrates proper usage of @trailhead libraries:
 * - @trailhead/fs for filesystem operations with Result types
 * - Zod for configuration schema validation
 * - @trailhead/core for error handling
 */
export const configCommand = createCommand<ConfigCommandOptions>({
  name: 'config',
  description: 'Manage application configuration',
  options: [
    {
      flags: '--init',
      description: 'Initialize a new configuration file',
      type: 'boolean',
    },
    {
      flags: '--validate',
      description: 'Validate existing configuration',
      type: 'boolean',
    },
    {
      flags: '--show',
      description: 'Show current configuration',
      type: 'boolean',
    },
  ],
  async action(options, context): Promise<Result<void, CoreError>> {
    const configPath = resolve('config.json')

    if (options.init) {
      return initConfig(configPath, context.logger)
    }

    if (options.validate) {
      return validateConfig(configPath, context.logger)
    }

    if (options.show) {
      return showConfig(configPath, context.logger)
    }

    context.logger.info('Use --init, --validate, or --show to manage configuration')
    return ok(undefined)
  },
})

/**
 * Initialize a new configuration file
 * Demonstrates @trailhead/fs writeJson with Result-based error handling
 */
async function initConfig(
  configPath: string,
  logger: CommandContext['logger']
): Promise<Result<void, CoreError>> {
  // Check if file already exists using @trailhead/fs
  const existsResult = await fs.exists(configPath)
  if (existsResult.isErr()) {
    return err(
      createCoreError('CONFIG_CHECK_FAILED', 'CLI_ERROR', 'Failed to check configuration file', {
        recoverable: true,
        cause: existsResult.error,
      })
    )
  }

  if (existsResult.value) {
    logger.info('Configuration file already exists. Use --validate to check it.')
    return ok(undefined)
  }

  // Create default configuration
  const defaultConfig: Config = {
    name: '{{packageName}}',
    version: '{{version}}',
    environment: 'development',
    theme: {
      color: 'cyan',
    },
    settings: {
      debug: false,
      verbose: false,
    },
  }

  // Write configuration using @trailhead/fs writeJson
  const writeResult = await fs.writeJson(configPath, defaultConfig, { spaces: 2 })
  if (writeResult.isErr()) {
    return err(
      createCoreError('CONFIG_INIT_FAILED', 'CLI_ERROR', 'Failed to initialize configuration', {
        recoverable: true,
        cause: writeResult.error,
      })
    )
  }

  logger.success(`Configuration file created at ${configPath}`)
  return ok(undefined)
}

/**
 * Validate configuration file
 * Demonstrates @trailhead/fs readJson and Zod schema validation
 */
async function validateConfig(
  configPath: string,
  logger: CommandContext['logger']
): Promise<Result<void, CoreError>> {
  // Read configuration using @trailhead/fs
  const readResult = await fs.readJson<unknown>(configPath)
  if (readResult.isErr()) {
    return err(
      createCoreError(
        'CONFIG_NOT_FOUND',
        'CLI_ERROR',
        `Configuration file not found: ${configPath}`,
        { recoverable: true, cause: readResult.error }
      )
    )
  }

  // Validate using Zod schema
  const validationResult = configSchema.safeParse(readResult.value)
  if (!validationResult.success) {
    logger.error('Configuration validation failed:')
    // Show validation errors with helpful messages
    validationResult.error.errors.forEach((error) => {
      logger.error(`  ${error.path.join('.')}: ${error.message}`)
    })
    return err(
      createCoreError('CONFIG_INVALID', 'CLI_ERROR', 'Configuration validation failed', {
        recoverable: true,
      })
    )
  }

  logger.success('Configuration is valid âœ“')
  return ok(undefined)
}

/**
 * Show current configuration
 * Demonstrates @trailhead/fs readJson with proper error handling
 */
async function showConfig(
  configPath: string,
  logger: CommandContext['logger']
): Promise<Result<void, CoreError>> {
  // Read configuration using @trailhead/fs
  const readResult = await fs.readJson<Config>(configPath)
  if (readResult.isErr()) {
    return err(
      createCoreError(
        'CONFIG_NOT_FOUND',
        'CLI_ERROR',
        `Configuration file not found: ${configPath}`,
        { recoverable: true, cause: readResult.error }
      )
    )
  }

  logger.info('Current configuration:')
  logger.info(JSON.stringify(readResult.value, null, 2))
  return ok(undefined)
}