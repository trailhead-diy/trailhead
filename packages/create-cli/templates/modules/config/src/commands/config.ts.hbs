import { createCommand, type CommandOptions } from '@trailhead/cli/command'
import { ok, err, createCoreError } from '@trailhead/core'
import { consola } from 'consola'
import { readFileSync, writeFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import { configSchema, type Config } from '../lib/config-schema.js'

interface ConfigCommandOptions extends CommandOptions {
  init?: boolean
  validate?: boolean
  show?: boolean
}

export const configCommand = createCommand<ConfigCommandOptions>({
  name: 'config',
  description: 'Manage application configuration',
  options: [
    {
      flags: '--init',
      description: 'Initialize a new configuration file',
      type: 'boolean'
    },
    {
      flags: '--validate',
      description: 'Validate existing configuration',
      type: 'boolean'
    },
    {
      flags: '--show',
      description: 'Show current configuration',
      type: 'boolean'
    }
  ],
  async action(options, context) {
    const configPath = resolve('config.json')

    if (options.init) {
      return initConfig(configPath)
    }

    if (options.validate) {
      return validateConfig(configPath)
    }

    if (options.show) {
      return showConfig(configPath)
    }

    context.logger.info('Use --init, --validate, or --show to manage configuration')
    return ok(undefined)
  }
})

function initConfig(configPath: string) {
  try {
    if (existsSync(configPath)) {
      consola.info('Configuration file already exists. Use --validate to check it.')
      return ok(undefined)
    }

    const defaultConfig: Config = {
      name: '{{packageName}}',
      version: '{{version}}',
      environment: 'development',
      settings: {
        debug: false,
        verbose: false
      }
    }

    writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2))
    consola.success(`Configuration file created at ${configPath}`)
    return ok(undefined)
  } catch (_error) {
    return err(createCoreError('CONFIG_INIT_FAILED', 'CLI_ERROR', 'Failed to initialize configuration', { recoverable: true }))
  }
}

function validateConfig(configPath: string) {
  try {
    if (!existsSync(configPath)) {
      return err(createCoreError('CONFIG_NOT_FOUND', 'CLI_ERROR', `Configuration file not found: ${configPath}`, { recoverable: true }))
    }

    const configData = readFileSync(configPath, 'utf-8')
    const config = JSON.parse(configData)
    const result = configSchema.safeParse(config)

    if (!result.success) {
      consola.error('Configuration validation failed:')
      result.error.errors.forEach(error => {
        consola.error(`  ${error.path.join('.')}: ${error.message}`)
      })
      return err(createCoreError('CONFIG_INVALID', 'CLI_ERROR', 'Configuration validation failed', { recoverable: true }))
    }

    consola.success('Configuration is valid âœ“')
    return ok(undefined)
  } catch (_error) {
    return err(createCoreError('CONFIG_VALIDATION_FAILED', 'CLI_ERROR', 'Failed to validate configuration', { recoverable: true }))
  }
}

function showConfig(configPath: string) {
  try {
    if (!existsSync(configPath)) {
      return err(createCoreError('CONFIG_NOT_FOUND', 'CLI_ERROR', `Configuration file not found: ${configPath}`, { recoverable: true }))
    }

    const configData = readFileSync(configPath, 'utf-8')
    const config = JSON.parse(configData)
    consola.info('Current configuration:')
    consola.box(JSON.stringify(config, null, 2))
    return ok(undefined)
  } catch (_error) {
    return err(createCoreError('CONFIG_SHOW_FAILED', 'CLI_ERROR', 'Failed to show configuration', { recoverable: true }))
  }
}