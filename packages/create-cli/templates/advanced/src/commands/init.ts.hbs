import { createCommand } from '@esteban-url/cli/command'
import type { CommandOptions } from '@esteban-url/cli/command'
import { ok, err } from '@esteban-url/core'
import type { Result, CoreError } from '@esteban-url/core'
import { input, select, confirm } from '@esteban-url/cli/prompts'
import { join } from 'path'

/**
 * Init Command
 * 
 * Advanced example demonstrating:
 * - Interactive project initialization
 * - Configuration file generation
 * - Multi-step setup process
 * - Validation and error recovery
 */
interface InitOptions extends CommandOptions {
  force?: boolean;
  template?: string;
  skipInstall?: boolean;
}

export const initCommand = createCommand<InitOptions>({
  name: 'init',
  description: 'Initialize a new project configuration',
  options: [
    {
      flags: '-f, --force',
      description: 'Overwrite existing configuration',
      type: 'boolean'
    },
    {
      flags: '-t, --template <template>',
      description: 'Project template to use',
      type: 'string'
    },
    {
      flags: '--skip-install',
      description: 'Skip dependency installation',
      type: 'boolean'
    }
  ],
  action: async (options, context) => {
    const { logger, verbose } = context
    
    try {
      logger.info('Initializing project configuration...')
      
      // Check for existing configuration
      const configPath = join(process.cwd(), '{{packageName}}.config.js')
      const { existsSync } = await import('fs')
      const configExists = existsSync(configPath)
      
      if (configExists && !options.force) {
        logger.error('Configuration file already exists')
        const shouldOverwrite = await confirm({
          message: 'Overwrite existing configuration?',
          default: false
        })
        
        if (!shouldOverwrite) {
          logger.info('Initialization cancelled')
          return ok(undefined)
        }
      }
      
      // Gather project information
      const projectName = await input({
        message: 'Project name:',
        default: process.cwd().split('/').pop() || 'my-project',
        validate: (value) => value.length > 0 ? true : 'Project name is required'
      })
      
      const projectType = await select({
        message: 'Project type:',
        choices: [
          { name: 'Library', value: 'library' },
          { name: 'Application', value: 'application' },
          { name: 'CLI Tool', value: 'cli' },
          { name: 'API Server', value: 'api' }
        ]
      })
      
      const enableLinting = await confirm({
        message: 'Enable linting?',
        default: true
      })
      
      const enableTesting = await confirm({
        message: 'Enable testing setup?',
        default: true
      })
      
      // Generate configuration
      const config = {
        name: projectName,
        type: projectType,
        version: '1.0.0',
        features: {
          linting: enableLinting,
          testing: enableTesting,
          typescript: true
        },
        build: {
          outDir: 'dist',
          target: 'node18'
        }
      }
      
      // Write configuration file
      const { writeFile } = await import('fs/promises')
      const configContent = `export default ${JSON.stringify(config, null, 2)}`
      
      try {
        await writeFile(configPath, configContent)
      } catch (error) {
        logger.error(`Failed to write configuration: ${error instanceof Error ? error.message : String(error)}`)
        return err({
          code: 'CONFIG_WRITE_FAILED',
          message: 'Failed to write configuration file',
          details: {
            path: configPath
          },
          cause: error instanceof Error ? error : undefined,
          suggestion: 'Check file permissions and try again'
        } satisfies CoreError)
      }
      
      logger.success(`Configuration created: ${configPath}`)
      
      // Create basic project structure
      // Tests use colocation pattern (src/**/__tests__/) instead of separate tests/ directory
      const directories = ['src', 'docs']
      for (const dir of directories) {
        try {
          await context.fs.ensureDir(dir)
          if (verbose) {
            logger.debug(`Created directory: ${dir}`)
          }
        } catch (error) {
          logger.error(`Failed to create directory: ${dir}`)
        }
      }
      
      // Create initial files
      if (projectType === 'cli') {
        const cliTemplate = `#!/usr/bin/env node
console.log('Hello from ${projectName}!')
`
        try {
          await writeFile('src/index.ts', cliTemplate)
        } catch (error) {
          logger.error(`Failed to create CLI entry point: ${error instanceof Error ? error.message : String(error)}`)
        }
        logger.info('Created CLI entry point: src/index.ts')
      }
      
      logger.success('Project initialization completed!')
      logger.info('')
      logger.info('Next steps:')
      logger.info('  1. Review the generated configuration')
      logger.info('  2. Install dependencies')
      logger.info('  3. Start developing!')
      
      return ok(undefined)
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Initialization failed: ${errorMessage}`)
      return err({
        code: 'INIT_FAILED',
        message: `Init failed: ${errorMessage}`,
        details: {
          operation: 'init'
        },
        cause: error instanceof Error ? error : undefined
      } satisfies CoreError)
    }
  }
})