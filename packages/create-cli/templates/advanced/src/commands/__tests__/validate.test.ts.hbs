
import { describe, it, expect, beforeEach, vi } from 'vitest' import { createTestContext } from
'@esteban-url/trailhead-cli/testing' import { validateCommand } from '../validate.js' // Mock glob
and fs/promises vi.mock('glob', () => ({ glob: vi.fn() })) vi.mock('fs/promises', () => ({ readFile:
vi.fn() })) describe('validate command', () => { let testContext: any const mockGlob = vi.fn() const
mockReadFile = vi.fn() beforeEach(async () => { vi.clearAllMocks() testContext = createTestContext({
verbose: false }) // Setup default mocks mockGlob.mockResolvedValue([])
mockReadFile.mockResolvedValue('export const example = "test"') // Replace mocked modules const
globModule = vi.mocked(await import('glob')) const fsModule = vi.mocked(await import('fs/promises'))
globModule.glob.mockImplementation(mockGlob) fsModule.readFile.mockImplementation(mockReadFile) })
it('should validate all files by default', async () => { mockGlob
.mockResolvedValueOnce(['package.json']) // config files .mockResolvedValueOnce(['src/index.ts']) //
source files .mockResolvedValueOnce(['tests/index.test.ts']) // test files const result = await
validateCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.info).toHaveBeenCalledWith('Running project validation...')
expect(testContext.logger.isOk()).toHaveBeenCalledWith('Validation completed successfully!') })
it('should validate only configuration files when specified', async () => {
mockGlob.mockResolvedValue(['package.json', 'tsconfig.json']) const result = await
validateCommand.execute({ config: true }, testContext) expect(result.isOk()).toBe(true)
expect(mockGlob).toHaveBeenCalledWith('**/*.config.{js,ts,json}', { ignore: 'node_modules/**' })
expect(mockGlob).toHaveBeenCalledTimes(1) // Only config validation }) it('should validate only
source files when specified', async () => { mockGlob.mockResolvedValue(['src/index.ts',
'src/utils.ts']) const result = await validateCommand.execute({ source: true }, testContext)
expect(result.isOk()).toBe(true) expect(mockGlob).toHaveBeenCalledWith('src/**/*.{ts,js}', { ignore:
'node_modules/**' }) expect(mockGlob).toHaveBeenCalledTimes(1) // Only source validation })
it('should validate only test files when specified', async () => {
mockGlob.mockResolvedValue(['tests/index.test.ts']) const result = await validateCommand.execute({
tests: true }, testContext) expect(result.isOk()).toBe(true)
expect(mockGlob).toHaveBeenCalledWith('tests/**/*.{ts,js}', { ignore: 'node_modules/**' })
expect(mockGlob).toHaveBeenCalledTimes(1) // Only test validation }) it('should use custom pattern
when provided', async () => { mockGlob.mockResolvedValue(['custom/path/file.ts']) const result =
await validateCommand.execute({ source: true, pattern: 'custom/**/*.ts' }, testContext)
expect(result.isOk()).toBe(true) expect(mockGlob).toHaveBeenCalledWith('custom/**/*.ts', { ignore:
'node_modules/**' }) }) it('should detect console.log warnings in source files', async () => {
mockGlob.mockResolvedValue(['src/debug.ts']) mockReadFile.mockResolvedValue('console.log("debug
info"); export const value = 42;') const result = await validateCommand.execute({ source: true },
testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('src/debug.ts: Contains console.log
statements') }) it('should detect any type warnings in TypeScript files', async () => {
mockGlob.mockResolvedValue(['src/types.ts']) mockReadFile.mockResolvedValue('export function
process(data: any): void {}') const result = await validateCommand.execute({ source: true },
testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('src/types.ts: Contains "any" type -
consider more specific types') }) it('should detect files without exports', async () => {
mockGlob.mockResolvedValue(['src/script.ts']) mockReadFile.mockResolvedValue('console.log("no
exports here")') const result = await validateCommand.execute({ source: true }, testContext)
expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('src/script.ts: File does not export
anything') }) it('should detect empty configuration files', async () => {
mockGlob.mockResolvedValue(['empty.config.js']) mockReadFile.mockResolvedValue('') const result =
await validateCommand.execute({ config: true }, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('empty.config.js: Configuration file is
empty') }) it('should detect test files without test cases', async () => {
mockGlob.mockResolvedValue(['tests/empty.test.ts']) mockReadFile.mockResolvedValue('export const
helper = () => {}') const result = await validateCommand.execute({ tests: true }, testContext)
expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('tests/empty.test.ts: Test file does not
contain test cases') }) it('should detect focused tests as errors', async () => {
mockGlob.mockResolvedValue(['tests/focused.test.ts'])
mockReadFile.mockResolvedValue('describe("test", () => { it.only("should work", () => {}) })') const
result = await validateCommand.execute({ tests: true }, testContext)
expect(result.isOk()).toBe(false)
expect(testContext.logger.error).toHaveBeenCalledWith('tests/focused.test.ts: Contains focused tests
(.only)') }) it('should handle file read errors', async () => {
mockGlob.mockResolvedValue(['src/broken.ts']) mockReadFile.mockRejectedValue(new Error('Permission
denied')) const result = await validateCommand.execute({ source: true }, testContext)
expect(result.isOk()).toBe(false)
expect(testContext.logger.error).toHaveBeenCalledWith('src/broken.ts: Failed to validate source
file: Error: Permission denied') }) it('should handle glob discovery errors', async () => {
mockGlob.mockRejectedValue(new Error('Glob pattern error')) const result = await
validateCommand.execute({ source: true }, testContext) expect(result.isOk()).toBe(false)
expect(testContext.logger.error).toHaveBeenCalledWith('source-discovery: Failed to discover source
files: Error: Glob pattern error') }) it('should attempt to fix issues when fix flag is provided',
async () => { mockGlob.mockResolvedValue(['tests/focused.test.ts'])
mockReadFile.mockResolvedValue('describe("test", () => { it.only("should work", () => {}) })') const
consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {}) const result = await
validateCommand.execute({ tests: true, fix: true }, testContext) expect(result.isOk()).toBe(false)
// Still fails due to error expect(testContext.logger.info).toHaveBeenCalledWith('Attempting to fix
validation issues...') expect(testContext.logger.info).toHaveBeenCalledWith('Fixed 1 issues, 0
failed') expect(consoleSpy).toHaveBeenCalledWith('Would fix: tests/focused.test.ts - Contains
focused tests (.only)') consoleSpy.mockRestore() }) it('should provide validation summary', async ()
=> { mockGlob .mockResolvedValueOnce(['valid.config.js']) .mockResolvedValueOnce(['src/good.ts'])
.mockResolvedValueOnce(['tests/bad.test.ts']) mockReadFile .mockResolvedValueOnce('export default
{}') // config .mockResolvedValueOnce('export const value = 42') // source
.mockResolvedValueOnce('describe("test", () => { it.only("should work", () => {}) })') // test with
error const result = await validateCommand.execute({}, testContext)
expect(result.isOk()).toBe(false) expect(testContext.logger.info).toHaveBeenCalledWith('Validation
Summary:') expect(testContext.logger.info).toHaveBeenCalledWith(' ✓ 2 passed')
expect(testContext.logger.error).toHaveBeenCalledWith(' ✗ 1 errors') }) it('should log verbose
information when enabled', async () => { testContext.verbose = true
mockGlob.mockResolvedValue(['src/index.ts']) const consoleSpy = vi.spyOn(console,
'log').mockImplementation(() => {}) const result = await validateCommand.execute({ source: true },
testContext) expect(result.isOk()).toBe(true) expect(consoleSpy).toHaveBeenCalledWith('Validating
source: src/index.ts') consoleSpy.mockRestore() }) it('should handle unexpected errors during
validation', async () => { mockGlob.mockImplementation(() => { throw new Error('Unexpected
validation error') }) const result = await validateCommand.execute({}, testContext)
expect(result.isOk()).toBe(false) expect(testContext.logger.error).toHaveBeenCalledWith('Validation
failed: Unexpected validation error') }) it('should show warnings in verbose mode', async () => {
testContext.verbose = true mockGlob.mockResolvedValue(['src/warning.ts'])
mockReadFile.mockResolvedValue('console.log("debug")') const result = await
validateCommand.execute({ source: true }, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warning).toHaveBeenCalledWith('src/warning.ts: Contains console.log
statements') }) it('should show info messages in verbose mode', async () => { testContext.verbose =
true mockGlob.mockResolvedValue(['src/good.ts']) mockReadFile.mockResolvedValue('export const value
= 42') const result = await validateCommand.execute({ source: true }, testContext)
expect(result.isOk()).toBe(true) expect(testContext.logger.info).toHaveBeenCalledWith('src/good.ts:
Source file validated') }) })