import { describe, it, expect, beforeEach, vi } from 'vitest' import { createTestContext,
mockFileSystem } from '@esteban-url/trailhead-cli/testing' import { initCommand } from '../init.js'
// Mock inquirer prompts vi.mock('@esteban-url/trailhead-cli/prompts', () => ({ input: vi.fn(),
select: vi.fn(), confirm: vi.fn() })) describe('init command', () => { let testContext: any const
mockInput = vi.fn() const mockSelect = vi.fn() const mockConfirm = vi.fn() beforeEach(async () => {
vi.clearAllMocks() testContext = createTestContext({ verbose: false, fs: mockFileSystem({}) }) //
Setup default mocks mockInput.mockResolvedValue('my-awesome-project')
mockSelect.mockResolvedValue('cli') mockConfirm.mockResolvedValue(true) // Replace mocked modules
const inquirerModule = vi.mocked(await import('@esteban-url/trailhead-cli/prompts'))
inquirerModule.input.mockImplementation(mockInput)
inquirerModule.select.mockImplementation(mockSelect)
inquirerModule.confirm.mockImplementation(mockConfirm) }) it('should initialize project
successfully', async () => { testContext.fs.exists.mockResolvedValue({ success: true, value: false
}) testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined }) const result =
await initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.info).toHaveBeenCalledWith('Initializing project configuration...')
expect(testContext.logger.isOk()).toHaveBeenCalledWith('Project initialization completed!') })
it('should handle existing configuration without force flag', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: true })
mockConfirm.mockResolvedValueOnce(false) // Don't overwrite const result = await
initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warn).toHaveBeenCalledWith('Configuration file already exists')
expect(testContext.logger.info).toHaveBeenCalledWith('Initialization cancelled') }) it('should
overwrite existing configuration when confirmed', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: true })
mockConfirm.mockResolvedValueOnce(true) // Overwrite mockConfirm.mockResolvedValueOnce(true) //
Enable linting mockConfirm.mockResolvedValueOnce(true) // Enable testing
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined }) const result =
await initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(mockConfirm).toHaveBeenCalledWith({ message: 'Overwrite existing configuration?', default:
false }) }) it('should skip confirmation with force flag', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: true })
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined }) const result =
await initCommand.execute({ force: true }, testContext) expect(result.isOk()).toBe(true) // Should
not ask for overwrite confirmation expect(mockConfirm).not.toHaveBeenCalledWith({ message:
'Overwrite existing configuration?', default: false }) }) it('should gather project information
through prompts', async () => { testContext.fs.exists.mockResolvedValue({ success: true, value:
false }) testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined })
mockInput.mockResolvedValue('test-project') mockSelect.mockResolvedValue('library')
mockConfirm.mockResolvedValueOnce(false) // Disable linting mockConfirm.mockResolvedValueOnce(true)
// Enable testing const result = await initCommand.execute({}, testContext)
expect(result.isOk()).toBe(true) expect(mockInput).toHaveBeenCalledWith({ message: 'Project name:',
default: expect.any(String), validate: expect.any(Function) })
expect(mockSelect).toHaveBeenCalledWith({ message: 'Project type:', choices:
expect.arrayContaining([ { name: 'Library', value: 'library' }, { name: 'CLI Tool', value: 'cli' }
]) }) }) it('should validate project name input', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: false }) // Test the validation
function const validateFn = mockInput.mock.calls[0]?.[0]?.validate expect(validateFn).toBeDefined()
if (validateFn) { expect(validateFn('')).toBe('Project name is required')
expect(validateFn('valid-name')).toBe(true) } }) it('should create directory structure', async () =>
{ testContext.fs.exists.mockResolvedValue({ success: true, value: false })
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined }) const result =
await initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.fs.ensureDirectory).toHaveBeenCalledWith('src')
expect(testContext.fs.ensureDirectory).toHaveBeenCalledWith('tests')
expect(testContext.fs.ensureDirectory).toHaveBeenCalledWith('docs') }) it('should create CLI entry
point for CLI projects', async () => { testContext.fs.exists.mockResolvedValue({ success: true,
value: false }) testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined })
mockSelect.mockResolvedValue('cli') mockInput.mockResolvedValue('my-cli') const result = await
initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.fs.writeFile).toHaveBeenCalledWith( 'src/index.ts',
expect.stringContaining('Hello from my-cli!') )
expect(testContext.logger.info).toHaveBeenCalledWith('Created CLI entry point: src/index.ts') })
it('should handle configuration write failure', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: false })
testContext.fs.writeFile.mockResolvedValue({ success: false, error: new Error('Permission denied')
}) const result = await initCommand.execute({}, testContext) expect(result.isOk()).toBe(false)
expect(testContext.logger.error).toHaveBeenCalledWith('Failed to write configuration: Permission
denied') }) it('should handle directory creation failures gracefully', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: false })
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValueOnce({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValueOnce({ success: false, error: new Error('Permission
denied') }) testContext.fs.ensureDirectory.mockResolvedValueOnce({ success: true, value: undefined
}) const result = await initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.warn).toHaveBeenCalledWith('Failed to create directory: tests') })
it('should log debug information in verbose mode', async () => { testContext.verbose = true
testContext.fs.exists.mockResolvedValue({ success: true, value: false })
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined }) const result =
await initCommand.execute({}, testContext) expect(result.isOk()).toBe(true)
expect(testContext.logger.debug).toHaveBeenCalledWith('Created directory: src') }) it('should handle
unexpected errors', async () => { testContext.fs.exists.mockRejectedValue(new Error('Filesystem
error')) const result = await initCommand.execute({}, testContext) expect(result.isOk()).toBe(false)
expect(testContext.logger.error).toHaveBeenCalledWith('Initialization failed: Filesystem error') })
it('should generate correct configuration content', async () => {
testContext.fs.exists.mockResolvedValue({ success: true, value: false })
testContext.fs.writeFile.mockResolvedValue({ success: true, value: undefined })
testContext.fs.ensureDirectory.mockResolvedValue({ success: true, value: undefined })
mockInput.mockResolvedValue('test-project') mockSelect.mockResolvedValue('application')
mockConfirm.mockResolvedValueOnce(true) // Enable linting mockConfirm.mockResolvedValueOnce(false)
// Disable testing const result = await initCommand.execute({}, testContext)
expect(result.isOk()).toBe(true) const writeCall = testContext.fs.writeFile.mock.calls.find(call =>
call[0].includes('{{packageName}}.config.js') ) expect(writeCall).toBeDefined() const configContent
= writeCall[1] expect(configContent).toContain('"name": "test-project"')
expect(configContent).toContain('"type": "application"') expect(configContent).toContain('"linting":
true') expect(configContent).toContain('"testing": false') }) })